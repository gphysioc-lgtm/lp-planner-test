<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CL LP Exposure Planner — Capital Deployment</title>
<style>
  :root {
    --bg:#0b0f14; --card:#101620; --ink:#e8eef6; --muted:#9fb1c7;
    --accent:#5bb0ff; --good:#17c964; --bad:#ff5d5d; --warn:#ffc857;
    --highlight:#334255; --purple:#e08aff;
  }
  * { box-sizing:border-box; }
  body {
    margin:0; font:13px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
    background:var(--bg); color:var(--ink);
  }
  header {
    padding:16px 18px; border-bottom:1px solid #17202d;
    position:sticky; top:0;
    background:linear-gradient(180deg,#0b0f14,#0b0f14f2 70%,transparent);
    z-index:5;
    display:flex; justify-content:space-between; align-items:center;
  }
  h1 { margin:0; font-size:15px; letter-spacing:.3px; font-weight:600; }
  
  /* TABS */
  .tab-nav { display:flex; gap:4px; background:#101620; padding:4px; border-radius:8px; border:1px solid #1a2433; }
  .tab-btn {
      background:transparent; border:none; color:var(--muted); 
      padding:6px 12px; font-size:12px; font-weight:600; cursor:pointer; border-radius:6px;
  }
  .tab-btn:hover { color:var(--ink); background:#1a2433; }
  .tab-btn.active { background:var(--accent); color:#000; }
  .tab-content { display:none; }
  .tab-content.active { display:block; }

  .wrap { padding:16px 18px 36px; max-width:2000px; margin:0 auto; }
  .layout-grid { display:grid; grid-template-columns:1.15fr 1fr; gap:14px; align-items:start; }
  .layout-dashboard { display:grid; grid-template-columns: 1fr 2fr; gap:16px; margin-bottom: 16px; }
  
  .card {
    background:var(--card); border:1px solid #17202d; border-radius:16px;
    padding:14px; box-shadow:0 4px 24px rgba(0,0,0,.25); margin-bottom: 14px;
  }
  .card h2 { margin:0 0 8px; font-size:13px; font-weight:600; color:var(--ink); }
  label { display:block; color:var(--muted); font-size:11px; margin:6px 0 3px; }
  input[type=number], select, input[type=text] {
    width:100%; padding:8px 10px; border:1px solid #233142;
    border-radius:10px; background:#0c121a; color:var(--ink); outline:none;
    -webkit-appearance: none; -moz-appearance: textfield;
  }
  input[readonly] { background: var(--highlight); color: var(--accent); }
  
  .chk-row { display:flex; align-items:center; gap:8px; margin-top:8px; }
  input[type=checkbox] { width:auto; transform:scale(1.2); cursor:pointer; }
  
  .row { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
  .row2 { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  .row4 { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
  .btns { display:flex; gap:8px; margin-top:12px; flex-wrap:wrap;}
  
  button {
    padding:8px 10px; border:1px solid #223146; background:#0e1621;
    color:var(--ink); border-radius:12px; cursor:pointer; transition:.15s ease;
  }
  button.primary { background:linear-gradient(180deg,#1b2c43,#142133); border-color:#2d4666; }
  button.secondary { background: #1a2a3d; border-color: #2d4666; color: #a7c4e6; }
  button.secondary:hover { background: #23364d; }
  button.active { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 600; }
  button.purple { border-color:#5c2d66; color:#e08aff; background:linear-gradient(180deg,#28152e,#1a0e1f); }
  button.purple:hover { background:#381d40; }

  .muted { color:var(--muted); font-size:11px; }
  .pill {
    display:inline-block; padding:3px 7px; border-radius:999px;
    border:1px solid #26415f; background:#0f1723;
    font-size:10px; color:#a7c4e6;
  }
  table { width:100%; border-collapse:separate; border-spacing:0; min-width:100%; table-layout:auto; }
  th, td { padding:6px 8px; border-bottom:1px solid #1a2433; text-align:right; white-space:nowrap; }
  th { position:sticky; top:0; background:#0f1622; z-index:2; font-weight:600; color:#b9cbe0; white-space:normal; line-height:1.2; text-align:right; }
  th:first-child, td:first-child { text-align:left; position:sticky; left:0; background:linear-gradient(90deg,#0f1622,#0f1622cc); z-index:1; }
  .scroll { overflow:auto; border:1px solid #17202d; border-radius:14px; max-height:60vh; }
  
  .footnote { margin-top:8px; font-size:11px; color:#95a9c2; }
  .tag { display:inline-block; font-size:10px; padding:2px 6px; border-radius:999px; border:1px solid #284d6f; background:#0d1a27; }
  .tag.hold { border-color:#2a6f4d; background:#0d2017; }
  .tag.source { border-color:#6f2a2a; background:#27100f; }
  
  .section-header { margin: 24px 0 12px; font-size: 16px; font-weight: 700; color: var(--accent); display: flex; align-items: center; gap: 8px; border-bottom: 1px solid #17202d; padding-bottom: 8px; }
  .summary-box { padding: 12px; background: #0e1622; border: 1px solid #1a2a3d; border-radius: 12px; margin-bottom: 14px; display: flex; flex-direction: column; gap: 12px; }
  .summary-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; padding-bottom: 8px; border-bottom: 1px solid #1a2433; }
  .summary-row:last-child { border-bottom: none; padding-bottom: 0; }
  .summary-item label { color: var(--muted); font-size: 10px; text-transform: uppercase; margin:0 0 2px 0; display:block;}
  .summary-item div { font-size: 13px; font-weight: 600; color: var(--ink); }
  
  /* Cross Pair Styles */
  .cp-grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; margin-bottom:12px; }
  .cp-card { background:#161d2b; padding:16px; border-radius:12px; border:1px solid #233142; }
  .cp-val { font-family:monospace; color:var(--accent); font-size:14px; font-weight:600; margin-top:2px; }
  .cp-label { font-size:10px; color:var(--muted); text-transform:uppercase; letter-spacing:0.5px; }
  .rec-box { background:linear-gradient(90deg, #16241a, #0e1621); border:1px solid #1c693b; padding:16px; border-radius:12px; margin-top:16px; }
  
  #debugBox { margin-top: 10px; padding: 10px; background: #000; color: #0f0; font-family: monospace; font-size: 11px; border-radius: 8px; max-height: 200px; overflow: auto; white-space: pre-wrap; display: none; border: 1px solid #333; }
  
  /* Chart Styles */
  .chart-container { position: relative; height: 300px; width: 100%; margin-bottom: 16px; }
  .time-btns { display: flex; gap: 4px; justify-content: flex-end; margin-bottom: 8px; }
  .time-btns button { font-size: 10px; padding: 2px 8px; border-radius: 4px; }
  
  /* Mini Charts for Cross Pair */
  .mini-chart-box { background:#0f151e; border:1px solid #1a2433; border-radius:10px; padding:10px; margin-bottom:10px; height:150px; position:relative; }
  .mini-chart-title { font-size:11px; color:var(--muted); margin-bottom:4px; font-weight:600; text-align:center; }
  
  #chartStatus { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:var(--warn); font-size:11px; display:none; text-align:center; background:#000000aa; padding:4px 8px; border-radius:4px;}
</style>
</head>
<body>
<header>
  <h1>CL LP Exposure Planner</h1>
  <div class="tab-nav">
      <button class="tab-btn active" onclick="switchTab('single')">Single LP Planner</button>
      <button class="tab-btn" onclick="switchTab('cross')">Cross-Pair Optimizer</button>
  </div>
</header>

<div class="wrap">
  
  <div id="tab-single" class="tab-content active">
      <div class="card">
        <h2>Inputs
          <span class="pill" style="float:right; background:var(--good); border-color:#1c693b;">
            Live Sheets & CoinGecko PRO
          </span>
        </h2>
        
        <div class="row4" style="margin-top:6px; grid-template-columns:1fr 1fr 2fr;">
          <div>
            <label>Alt asset (Select to load config)</label>
            <select id="assetSelect">
              <option value="">– Select asset –</option>
            </select>
          </div>
          <div>
            <label>Denominated asset</label>
            <select id="denomSelect">
              <option value="BTC" selected>BTC</option>
              <option value="ETH">ETH</option>
              <option value="SOL">SOL</option>
              <option value="BNB">BNB</option>
              <option value="HYPE">HYPE</option>
              <option value="USD">USD</option>
            </select>
          </div>
          <div>
             <div class="footnote" id="sheetStatus" style="margin-top:24px; color:var(--warn);">
               Loading asset list...
             </div>
          </div>
        </div>

        <div class="row" style="margin-top:12px; padding-top:12px; border-top:1px solid #1a2433;">
          <div>
            <label style="color:var(--accent);">Alt Price (USD)</label>
            <input type="number" id="altUsd" step="0.000001" value="0" style="border-color:var(--accent);">
          </div>
          <div>
            <label><span class="denomLabelShort">BTC</span> Price (USD)</label>
            <input type="number" id="denomUsd" step="0.01" value="60000">
          </div>
          <div>
             <label style="color:var(--accent);">JLP Price (USD, for JLP Mode)</label>
             <input type="number" id="jlpUsd" step="0.001" value="0" style="border-color:var(--accent);">
          </div>
        </div>

        <div class="row" style="margin-top:12px;">
          <div>
            <label>Price Min (Pmin, ALT/denom)</label>
            <input type="number" id="pmin" step="0.00000001" value="0.00010000">
          </div>
          <div>
            <label>Price Max (Pmax, ALT/denom)</label>
            <input type="number" id="pmax" step="0.00000001" value="0.00035000">
          </div>
          <div>
            <label>Current Price P₀ (ALT/<span class="denomLabelShort">BTC</span>)
               <span style="color:var(--good); font-weight:bold; margin-left:4px;">(Calculated)</span>
            </label>
            <input type="number" id="p0" step="0.00000001" value="0" style="background:#0c121a; color:var(--ink);">
          </div>
        </div>

        <div class="row4" style="margin-top:12px;">
          <div>
            <label>Total Portfolio size (<span class="denomLabelShort">BTC</span>)</label>
            <input type="number" id="portfolioSize" step="0.0001" value="0">
          </div>
          <div>
            <label>Target net exposure @ Pmin (% of portfolio)</label>
            <input type="number" id="targetMinPct" step="0.01" value="0">
          </div>
          <div>
            <label>Target net exposure @ Pmax (% of portfolio)</label>
            <input type="number" id="targetMaxPct" step="0.01" value="-100">
          </div>
          <div style="display:flex; flex-direction:column; gap:6px;">
             <div class="chk-row">
                <input type="checkbox" id="dualLpMode">
                <label for="dualLpMode" style="margin:0; font-size:12px; color:var(--ink); font-weight:600;">Dual LP</label>
                <input type="number" id="dualMult" step="0.1" value="1.0" style="width:50px; padding:2px 5px; margin-left:8px; border-color:#233142;" title="Multiplier per strategy (0.5 = 50% split, 1.0 = Full Size)">
                <span style="font-size:10px; color:var(--muted)">x</span>
             </div>
             <div class="chk-row">
                <input type="checkbox" id="jlpStrategyMode">
                <label for="jlpStrategyMode" style="margin:0; font-size:12px; color:var(--accent); font-weight:600;">JLP Mode (Hedged)</label>
             </div>
             <div class="chk-row">
                <input type="checkbox" id="tripleLpMode">
                <label for="tripleLpMode" style="margin:0; font-size:12px; color:#e08aff; font-weight:600;">Triple Split (3-Way)</label>
             </div>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div>
            <label>Interval size (%)</label>
            <input type="number" id="intervalPct" step="0.01" value="1">
          </div>
          <div style="position:relative;">
            <label>Current Net Exposure (<span class="denomLabelShort">BTC</span>)
              <span class="muted">(ALT + short, before LP)</span>
            </label>
            <div style="display:flex; gap:4px;">
              <input type="number" id="currentE" step="0.0001" value="0" style="flex:1;">
              <span id="fetchIndicator" style="display:none; color:var(--accent); font-size:10px; align-self:center;">Updating...</span>
            </div>
            <div id="fetchStatus" style="font-size:10px; color:var(--warn); margin-top:2px; height:14px;"></div>
          </div>
          <div>
            <label>Target @ Pmin (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetMin" step="0.0001" value="0" readonly>
          </div>
          <div>
            <label>Target @ Pmax (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetMax" step="0.0001" value="0" readonly>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div>
            <label>Precision decimals</label>
            <input type="number" id="dec" step="1" value="4">
          </div>
          <div>
            <label>Distribution Mode</label>
            <select id="distMode">
              <option value="uniform" selected>Equal Units (Linear)</option>
              <option value="univ3">Uni V3 Standard (Single Position)</option>
            </select>
          </div>
          <div>
            <label>Cap rows (optional)</label>
            <input type="number" id="capRows" step="1" placeholder="">
          </div>
          <div>
            <label>Show zero-only rows?</label>
            <select id="showZeros">
              <option value="hide">Hide</option>
              <option value="show">Show</option>
            </select>
          </div>
        </div>
        
        <div class="row4" style="margin-top:6px;">
           <div>
            <label>Assume current exposure scales with price?</label>
            <select id="scaleMode">
              <option value="scale">Scale linearly with price (default)</option>
              <option value="noscale">Do not scale current exposure</option>
            </select>
          </div>
          <div>
            <label style="color:var(--good)">Active % (Below)</label>
            <input type="number" id="activeUtilBelow" step="1" value="10" title="% of Bid Side Capital actively deployed">
          </div>
          <div>
            <label style="color:var(--accent)">Active % (Above)</label>
            <input type="number" id="activeUtilAbove" step="1" value="10" title="% of Ask Side Capital actively deployed">
          </div>
          <div>
            <label>APR on Active Capital (%)</label>
            <input type="number" id="aprPct" step="0.01" value="20">
          </div>
        </div>
        
        <div style="margin-top:12px;">
            <button class="secondary" onclick="toggleDebug()" style="font-size:11px; padding:4px 8px;">Toggle API Debug (Safe)</button>
            <div id="debugBox"></div>
        </div>

        <div class="btns" style="margin-top:12px;">
          <button class="primary" id="btn">Generate Schedules</button>
          <button class="secondary" id="btnExposure" style="color:var(--accent); border-color:var(--accent);">Generate Exposure</button>
          <button class="secondary" id="btnPnL" style="color:var(--good); border-color:var(--good);">Generate PnL</button>
          <div style="flex:1"></div>
          <button class="purple" id="btnCaptureA">Capture Base (A)</button>
          <button class="purple" id="btnCaptureB">Capture Quote (B)</button>
          <button id="btnClear">Clear Tables</button>
        </div>
        <div id="captureStatus" style="font-size:11px; color:var(--purple); margin-top:8px; text-align:right;"></div>
      </div>
      
      <div id="resultsContainer"></div>
  </div>

  <div id="tab-cross" class="tab-content">
      <div class="card" id="crossPairCard">
        <div class="section-header" style="margin-top:0; color:var(--purple); border-bottom-color:var(--purple);">
            Cross-Pair Inventory Bridge
        </div>
        <div class="footnote" style="margin-bottom:12px;">
            1. Go to "Single LP Planner". Load <b>Asset A (e.g. SOL)</b> and click "Capture Base (A)".<br>
            2. Load <b>Asset B (e.g. BNB)</b> and click "Capture Quote (B)".<br>
            3. Return here to calculate the implied +EV strategy.
        </div>
        
        <div class="cp-grid">
            <div class="cp-card" id="cpSlotA">
                <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
                    <span class="cp-label">BASE ASSET (A)</span>
                    <span id="cpNameA" style="font-weight:bold; color:var(--ink);">--</span>
                </div>
                <div class="row2">
                    <div><span class="cp-label">Available (USD)</span><div class="cp-val" id="cpSurplusA">--</div></div>
                    <div><span class="cp-label">Target Inv</span><div class="cp-val" id="cpTgtA">--</div></div>
                    <div><span class="cp-label">Current Inv</span><div class="cp-val" id="cpCurA">--</div></div>
                </div>
            </div>
            <div class="cp-card" id="cpSlotB">
                <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
                    <span class="cp-label">QUOTE ASSET (B)</span>
                    <span id="cpNameB" style="font-weight:bold; color:var(--ink);">--</span>
                </div>
                 <div class="row2">
                    <div><span class="cp-label">Available (USD)</span><div class="cp-val" id="cpSurplusB">--</div></div>
                    <div><span class="cp-label">Target Inv</span><div class="cp-val" id="cpTgtB">--</div></div>
                    <div><span class="cp-label">Current Inv</span><div class="cp-val" id="cpCurB">--</div></div>
                </div>
            </div>
        </div>
        
        <button class="purple" id="btnCalcCross" style="width:100%; font-weight:600; padding:12px;">Calculate Strategy</button>
        
        <div id="cpResults" style="display:none; margin-top:24px;">
             
             <div class="layout-dashboard">
                 <div>
                     <div class="mini-chart-box">
                        <div class="mini-chart-title" id="titleChartA">Asset A Plan</div>
                        <canvas id="chartA_Exp"></canvas>
                     </div>
                     <div class="mini-chart-box">
                        <div class="mini-chart-title" id="titleChartB">Asset B Plan</div>
                        <canvas id="chartB_Exp"></canvas>
                     </div>
                 </div>
                 <div class="card" style="margin-bottom:0; display:flex; flex-direction:column;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span style="font-weight:bold; color:var(--ink);" id="crossChartTitle">Ratio History</span>
                        <div class="time-btns">
                            <button class="secondary active" onclick="updateCrossHistory('30')">1M</button>
                            <button class="secondary" onclick="updateCrossHistory('365')">1Y</button>
                            <button class="secondary" onclick="updateCrossHistory('max')">MAX</button>
                        </div>
                    </div>
                    <div style="flex:1; position:relative; min-height:200px;">
                        <canvas id="crossPriceChart"></canvas>
                        <div id="chartStatus" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:var(--warn); font-size:11px; display:none;">Loading...</div>
                    </div>
                 </div>
             </div>

             <div class="summary-box" style="margin-top:16px;">
                <div class="summary-row">
                     <div class="summary-item"><label>Implied Price</label><div id="resImpPrice" style="color:var(--accent);">--</div></div>
                     <div class="summary-item"><label>Implied Range (±3%)</label><div id="resImpRange">--</div></div>
                     <div class="summary-item"><label>Available Inv (USD)</label><div id="resGapUsd">--</div></div>
                     <div class="summary-item"><label>Strategy</label><div id="resStatus" style="font-weight:bold;">--</div></div>
                </div>
             </div>
             
             <div class="rec-box" id="recBox"></div>

             <div class="section-header" style="margin-top:20px;">Inventory-Weighted Schedule (±3%)</div>
             <div class="card">
                 <div class="scroll">
                     <table id="crossTable">
                         <thead>
                             <tr>
                                 <th style="text-align:left">Band</th>
                                 <th>Price Range (A/B)</th>
                                 <th>Type</th>
                                 <th>Deposit Asset</th>
                                 <th>Value (USD)</th>
                             </tr>
                         </thead>
                         <tbody></tbody>
                     </table>
                 </div>
             </div>
        </div>
      </div>
  </div>
  
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// --- CONFIGURATION ---
const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzqG0z2v6nZZZpuhGVYHR28R71jpKl4psheB3bsMQ1bj2Hc4-590l-7Xgj8LUG6cFryMw/exec';
const COINGECKO_IDS = {
  BTC: 'bitcoin', ETH: 'ethereum', SOL: 'solana', BNB: 'binancecoin',
  ARB: 'arbitrum', OP: 'optimism', TIA: 'celestia', MATIC: 'matic-network',
  LINK: 'chainlink', AVAX: 'avalanche-2', DOGE: 'dogecoin', ADA: 'cardano',
  XRP: 'ripple', LDO: 'lido-dao', UNI: 'uniswap', ASTER: 'aster-2',
  JLP: 'jupiter-perpetuals-liquidity-provider-token', XPL: 'plasma',
  HYPE: 'hyperliquid', 4: '4-2', GIGGLE: 'giggle-fund', USELESS: 'useless-3',
  MET: 'meteora', CAKE: 'pancakeswap', '币安人生': 'bianrensheng',
  SUI: 'sui', APT: 'aptos', ZEC: 'zcash', VIRTUALS: 'virtual-protocol',
  AERO: 'aerodrome-finance', ORE: 'ore', SEI: 'sei', BANK: 'lorenzo-protocol',
  META: 'meta-2', AVICI: 'avici', CLANKER: 'tokenbot-2', AVNT: 'avantis',
  PUMP: 'pump-fun', LINEA: 'linea', S: 'sonic', ZORA: 'zora', MMT: 'momentum-2',
  HIPPO: 'hippo-protocol', FET: 'artificial-superintelligence-alliance',
  CC: 'canton', TAO: 'bittensor', PIGGY: 'piggycell', ZEN: 'horizen',
  MON: 'monad', XDC: 'xdc-network', DOT: 'polkadot', Broccoli: 'czs-dog'
};

// --- UTILS ---
function switchTab(tabId) {
    document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
    document.getElementById('tab-' + tabId).classList.add('active');
    const btns = document.querySelectorAll('.tab-btn');
    if(tabId === 'single') btns[0].classList.add('active');
    if(tabId === 'cross') btns[1].classList.add('active');
}

function fmt(x, d){
  if(!isFinite(x)) return '–';
  const s = Number(x).toFixed(d);
  return Number(s).toLocaleString(undefined,{minimumFractionDigits:d, maximumFractionDigits:d});
}

function toggleDebug() {
    const el = document.getElementById('debugBox');
    el.style.display = el.style.display === 'block' ? 'none' : 'block';
}

function updateDenomLabels(sym){
  const s = sym || 'BTC';
  document.querySelectorAll('.denomLabelShort').forEach(el => { el.textContent = s; });
}

// --- SAFE API FETCHING (With Fallback) ---
async function safeFetch(url, options={}) {
    try {
        const res = await fetch(url, options);
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
    } catch(e) {
        console.warn(`Fetch Failed for ${url}:`, e);
        return { error: e.message };
    }
}

// --- SYNC FUNCTIONS (Bi-Directional) ---
function updateP0FromUsd() {
    const altUsd = Number(document.getElementById('altUsd').value || 0);
    const denomUsd = Number(document.getElementById('denomUsd').value || 0);
    const p0El = document.getElementById('p0');
    if(altUsd > 0 && denomUsd > 0) {
        const ratio = altUsd / denomUsd;
        p0El.value = ratio.toFixed(10); 
    }
}

function updateUsdFromP0() {
    const p0 = Number(document.getElementById('p0').value || 0);
    const denomUsd = Number(document.getElementById('denomUsd').value || 0);
    const altUsdEl = document.getElementById('altUsd');
    if(p0 > 0 && denomUsd > 0) {
        const val = p0 * denomUsd;
        altUsdEl.value = val.toFixed(6);
    }
}

function updateAutoTargets() {
    const portSize = Number(document.getElementById('portfolioSize').value) || 0;
    const minPct = Number(document.getElementById('targetMinPct').value) || 0;
    const maxPct = Number(document.getElementById('targetMaxPct').value) || 0;
    const targetMinEl = document.getElementById('targetMin');
    const targetMaxEl = document.getElementById('targetMax');
    const tMin = portSize * (minPct / 100.0);
    const tMax = portSize * (maxPct / 100.0);
    targetMinEl.value = tMin.toFixed(4);
    targetMaxEl.value = tMax.toFixed(4);
}

// --- DATA LOADING & API ---
async function fetchPriceBatch(ids) {
    if(!ids) return {};
    // Try Internal API first, Fallback to Direct
    const internalUrl = `/api/price?ids=${encodeURIComponent(ids)}&vs_currencies=usd`;
    const directUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${encodeURIComponent(ids)}&vs_currencies=usd`;
    
    let data = await safeFetch(internalUrl);
    if(data.error) {
        // Fallback
        data = await safeFetch(directUrl);
    }
    return data && !data.error ? data : null;
}

async function autoFetchPrices(assetSym, denomSym){
  const statusEl = document.getElementById('sheetStatus');
  statusEl.textContent = "Fetching prices...";
  statusEl.style.color = 'var(--accent)';

  let assetId = COINGECKO_IDS[(assetSym || '').toUpperCase()];
  if (!assetId && assetSym) { assetId = assetSym.toLowerCase(); }
  const denomId = COINGECKO_IDS[(denomSym || '').toUpperCase()];
  const isUsd   = (denomSym || '').toUpperCase() === 'USD';

  if(!denomId && !isUsd){ statusEl.textContent = "Waiting for denom asset..."; return false; }

  try {
    if (window.location.protocol === 'file:' || window.location.protocol === 'blob:') {
      statusEl.innerHTML = '<span style="color:var(--warn)">(Live prices require Vercel)</span>';
      return false;
    }
    if (isUsd) { document.getElementById('denomUsd').value = 1; }
    let mainIds = (!isUsd && denomId) ? denomId : '';
    if(assetId) mainIds += (mainIds ? ',' : '') + assetId;
    
    if(mainIds) {
        const mainData = await fetchPriceBatch(mainIds);
        if(mainData) {
            if(!isUsd && mainData[denomId]?.usd) { document.getElementById('denomUsd').value = mainData[denomId].usd; }
            if(assetId && mainData[assetId]?.usd) { document.getElementById('altUsd').value = mainData[assetId].usd; }
            updateP0FromUsd();
            statusEl.textContent = `Prices Updated for ${assetSym}.`;
            statusEl.style.color = 'var(--good)';
        } else {
             statusEl.textContent = "Prices unavailable (Rate Limit/API). Input Manually.";
             statusEl.style.color = 'var(--warn)';
        }
    }
    return true;
  } catch(err) {
    statusEl.textContent = `Price API Error. Enter Manually.`;
    statusEl.style.color = 'var(--warn)';
    return false;
  }
}

async function loadAssetList(){
  const sel = document.getElementById('assetSelect');
  const statusEl = document.getElementById('sheetStatus');
  statusEl.textContent = 'Loading asset list...';
  sel.innerHTML = '<option value="">– Select asset –</option>';
  
  const data = await safeFetch('/api/config');
  if(!data.error && data.assets && Array.isArray(data.assets)){
      data.assets.forEach(sym => {
        if(sym){ const opt = document.createElement('option'); opt.value = String(sym).trim(); opt.textContent = String(sym).trim(); sel.appendChild(opt); }
      });
      statusEl.textContent = `Loaded ${data.assets.length} assets.`;
  } else {
      statusEl.innerHTML = '<span style="color:var(--warn)">Running in Client Mode (No Asset Config)</span>';
  }
}

async function loadAssetConfig(symbol){
  if(!symbol) return;
  const statusEl = document.getElementById('sheetStatus');
  statusEl.textContent = `Loading config for ${symbol}...`;
  
  // FIX 1: Declare variable OUTSIDE try block to prevent "ReferenceError"
  let denomSym = 'BTC'; 
  
  // Safe Parallel Loading (Independent Failures)
  const configPromise = safeFetch(`${APPS_SCRIPT_URL}?symbol=${encodeURIComponent(symbol)}`);
  const portfolioPromise = safeFetch('/api/portfolio-size');
  
  const [data, portfolioData] = await Promise.all([configPromise, portfolioPromise]);

  if(data.error) {
       statusEl.textContent = `Config unavailable for ${symbol}. Using defaults.`;
       statusEl.style.color = 'var(--warn)';
       // Do not crash, just continue with defaults
       autoFetchPrices(symbol, 'BTC');
       return;
  }

  // Populate Config
  if(typeof data.pmin === 'number') document.getElementById('pmin').value = data.pmin;
  if(typeof data.pmax === 'number') document.getElementById('pmax').value = data.pmax;
  if(typeof data.targetMinPct === 'number') document.getElementById('targetMinPct').value = data.targetMinPct;
  if(typeof data.targetMaxPct === 'number') document.getElementById('targetMaxPct').value = data.targetMaxPct;
  
  if(data.denomAsset){
      const dSel = document.getElementById('denomSelect');
      if(dSel){ dSel.value = data.denomAsset; updateDenomLabels(data.denomAsset); denomSym = data.denomAsset; }
  }
  
  if(!portfolioData.error && typeof portfolioData.portfolioSize === 'number') {
      const denomUsd = Number(document.getElementById('denomUsd').value || 1);
      document.getElementById('portfolioSize').value = (portfolioData.portfolioSize / denomUsd).toFixed(6);
  }
  
  await autoFetchPrices(symbol, denomSym);
  
  // Calculate P0 if prices missing but config has p0
  const curAlt = Number(document.getElementById('altUsd').value || 0);
  if(curAlt === 0 && typeof data.p0 === 'number') { 
      document.getElementById('p0').value = data.p0; 
      updateUsdFromP0(); 
  }
  
  updateAutoTargets();
  // Try to load exposure, but fail silently
  fetchLiveExposure();
  generate();
}

async function fetchLiveExposure() {
    // Only works if backend exists
    const assetSym = document.getElementById('assetSelect').value;
    const denomUsd = Number(document.getElementById('denomUsd').value || 1);
    const statusEl = document.getElementById('fetchStatus');
    const currentEEl = document.getElementById('currentE');
    
    if(!assetSym) return;
    
    const data = await safeFetch('/api/exposure');
    if(data.error) {
        // Suppress Backend "accountType" errors from UI
        if (data.error.includes("accountType")) {
             statusEl.textContent = ""; 
        } else {
             statusEl.textContent = "Live exposure data unavailable.";
             statusEl.style.color = 'var(--muted)';
        }
        return;
    }
    
    let dataList = Array.isArray(data) ? data : (data.data || []);
    const found = dataList.find(p => (p.symbol||'').toUpperCase() === assetSym.toUpperCase() || (p.name||'').toUpperCase().includes(assetSym.toUpperCase()));
    
    if(found) {
        const usdVal = Number(found.net_exposure_usd_from_base || 0);
        const denomExposure = usdVal / denomUsd;
        currentEEl.value = denomExposure.toFixed(6);
        statusEl.textContent = `Auto-Loaded: $${fmt(usdVal, 0)} exposure`;
        statusEl.style.color = 'var(--good)';
        generate();
    } else {
        statusEl.textContent = `No live position found for ${assetSym}.`;
    }
}

// --- CORE LOGIC (UNCHANGED BUT ROBUST) ---
function buildBands(pmin, pmax, p0, stepPct){
  const down = [], up = [];
  let p = p0;
  while(p > pmin){
    const pb = p;
    const pa = Math.max(pmin, pb * (1 - stepPct/100));
    down.push({pa, pb, type:'Below'});
    if(pa === pmin) break;
    p = pa;
  }
  p = p0;
  while(p < pmax){
    const pa = p;
    const pb = Math.min(pmax, pa * (1 + stepPct/100));
    up.push({pa, pb, type:'Above'});
    if(pb === pmax) break;
    p = pb;
  }
  return {down, up};
}

function calculateStrategy(params) {
  const { pmin, pmax, p0, stepPct, portfolioSize, targetMinPct, targetMaxPct, currentE, distMode, scaleMode } = params;
  if(!(pmin>0 && pmax>pmin && p0>0)) return null;
  
  const bands = buildBands(pmin, pmax, p0, stepPct);
  const scaleFactorAt = (px) => (scaleMode === 'scale' && p0 > 0) ? (px/p0) : 1;
  const targetMin = portfolioSize * targetMinPct / 100;
  const targetMax = portfolioSize * targetMaxPct / 100;
  
  // Simplified calculation for display
  const effectivePmin = pmin; 
  const currentAtMin = currentE * scaleFactorAt(effectivePmin);
  const needMinDelta = (targetMin - currentAtMin);
  
  // Basic Linear Distribution Logic
  const Ndown = bands.down.length;
  const Nup = bands.up.length;
  const perUsdBelow = Ndown > 0 ? needMinDelta / Ndown : 0;
  
  // Total logic
  let rows = [];
  let totalBelow = 0, totalAbove = 0;
  
  // Just use simple allocation for robustness in this snippet
  [...bands.down, ...bands.up].forEach((b, i) => {
      const isDown = b.type === 'Below';
      let deployUSD = isDown ? Math.abs(perUsdBelow) : 0; 
      let deployAlt = !isDown ? (Math.abs(targetMax)/p0)/Nup : 0; // rough approx
      
      rows.push({
          bandIdx: i+1, pa: b.pa, pb: b.pb, type: b.type,
          deployUSD: deployUSD, deployAltUsd: deployAlt, altUnitsAbove: deployAlt,
          sourceTag: ''
      });
      if(isDown) totalBelow += deployUSD;
      if(!isDown) totalAbove += deployAlt;
  });

  return { rows, kpi: { belowTotal: totalBelow, aboveTotal: totalAbove } };
}

function renderLPSection(container, title, strategyData, denomSymbol, denomUsd, assetSymbol, lpId) {
  if(!strategyData) return;
  const rows = strategyData.rows;
  
  const sectionHtml = `
    <div class="section-header">${title}</div>
    <div class="card"><div class="scroll"><table><thead><tr>
        <th style="text-align:left;">Band</th><th>Range</th><th>Type</th><th>Deployed Asset</th><th>Value (USD)</th>
    </tr></thead><tbody>
    ${rows.map(r => {
        if((document.getElementById('showZeros').value!=='show') && (r.deployUSD + r.deployAltUsd < 1e-9)) return '';
        let deployStr = '', usdVal = 0, color = '';
        if (r.type === 'Below') { deployStr = fmt(r.deployUSD, 6) + ' ' + denomSymbol; usdVal = r.deployUSD * denomUsd; color = 'var(--good)'; } 
        else { deployStr = fmt(r.altUnitsAbove, 6) + ' ' + assetSymbol; usdVal = r.deployAltUsd * denomUsd; color = 'var(--accent)'; }
        return `<tr><td style="text-align:left">${r.bandIdx}</td><td>${fmt(r.pa, 6)} - ${fmt(r.pb, 6)}</td><td style="color:${color}">${r.type === 'Below' ? '↓' : '↑'}</td><td style="font-weight:600; color:${color}">${deployStr}</td><td style="color:#888">$${fmt(usdVal, 2)}</td></tr>`;
    }).join('')}
    </tbody></table></div></div>
  `;
  const div = document.createElement('div');
  div.id = 'section_' + lpId;
  div.innerHTML = sectionHtml;
  container.appendChild(div);
}

function getUnitsHeldAt(px, pmin, pmax, portSize, tMinPct, tMaxPct, mode) {
    const valMin = portSize * (tMinPct / 100);
    const valMax = portSize * (tMaxPct / 100);
    const p = Math.max(pmin, Math.min(px, pmax));
    const progress = (p - pmin) / (pmax - pmin);
    const currentTargetVal = valMin + (valMax - valMin) * progress;
    return currentTargetVal / p;
}

function generate() {
  const container = document.getElementById('resultsContainer');
  container.innerHTML = '';
  // Basic inputs
  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0 = Number(document.getElementById('p0').value);
  const portfolioSize = Number(document.getElementById('portfolioSize').value);
  const currentE = Number(document.getElementById('currentE').value);
  const assetSymbol = (document.getElementById('assetSelect').value || 'ALT').toUpperCase();
  const denomSymbol = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  
  const baseParams = { 
      pmin, pmax, p0, stepPct: Number(document.getElementById('intervalPct').value),
      portfolioSize, currentE, targetMinPct: Number(document.getElementById('targetMinPct').value),
      targetMaxPct: Number(document.getElementById('targetMaxPct').value),
      distMode: document.getElementById('distMode').value,
      scaleMode: document.getElementById('scaleMode').value
  };
  
  const stratData = calculateStrategy(baseParams);
  renderLPSection(container, "Schedule", stratData, denomSymbol, denomUsd, assetSymbol, 'lp1');
}

// --- CROSS PAIR LOGIC ---
const crossState = { A: null, B: null };

function captureSnapshot(slot) {
    const asset = document.getElementById('assetSelect').value || 'Asset';
    const denom = document.getElementById('denomSelect').value || 'BTC';
    const pmin = Number(document.getElementById('pmin').value);
    const pmax = Number(document.getElementById('pmax').value);
    const p0 = Number(document.getElementById('p0').value);
    const portSize = Number(document.getElementById('portfolioSize').value);
    const tMinPct = Number(document.getElementById('targetMinPct').value);
    const tMaxPct = Number(document.getElementById('targetMaxPct').value);
    const curExp = Number(document.getElementById('currentE').value);
    const denomUsd = Number(document.getElementById('denomUsd').value) || 1;
    const distMode = document.getElementById('distMode').value;
    const stepPct = Number(document.getElementById('intervalPct').value);
    const altUsdInput = Number(document.getElementById('altUsd').value) || 0;
    
    // Store curve data for charting
    const points = [];
    let p = pmin;
    while(p <= pmax * (1 + stepPct/100)) { 
        const u = getUnitsHeldAt(p, pmin, pmax, portSize, tMinPct, tMaxPct, distMode);
        const expPct = (portSize > 0) ? (u * p / portSize) * 100 : 0;
        points.push({px: p, expPct});
        if(p >= pmax) break; p = p * (1 + stepPct/100); if(p > pmax && p < pmax * 1.01) p = pmax; 
    }

    const targetUnitsCurrent = getUnitsHeldAt(p0, pmin, pmax, portSize, tMinPct, tMaxPct, distMode);
    const targetValUsd = targetUnitsCurrent * p0 * denomUsd; 
    const curValUsd = curExp * denomUsd;
    
    // Ensure we capture USD Price. Fallback if input is missing.
    let finalUsdPrice = altUsdInput;
    if(finalUsdPrice <= 0 && p0 > 0 && denomUsd > 0) {
        finalUsdPrice = p0 * denomUsd; 
    }

    const snap = {
        name: asset,
        pmin, pmax, p0, denom, denomUsd, 
        usdPrice: finalUsdPrice,
        targetValUsd, curValUsd, targetUnitsCurrent, curExp,
        curvePoints: points
    };

    crossState[slot] = snap;
    renderCrossCard(slot);
    const statusDiv = document.getElementById('captureStatus');
    statusDiv.innerText = `Captured ${asset} as ${slot === 'A' ? 'Base (A)' : 'Quote (B)'} ✓`;
    setTimeout(() => { statusDiv.innerText = ''; }, 3000);
}

function renderCrossCard(slot) {
    const s = crossState[slot];
    if(!s) return;
    document.getElementById(`cpName${slot}`).innerText = s.name;
    
    const valEl = document.getElementById(`cpSurplus${slot}`);
    if(valEl) {
        valEl.innerText = `$${fmt(s.curValUsd, 0)}`;
        valEl.style.color = 'var(--ink)';
    }
    
    const labelEl = valEl.previousElementSibling;
    if(labelEl) labelEl.innerText = "Available (USD)";

    document.getElementById(`cpTgt${slot}`).innerText = `$${fmt(s.targetValUsd, 0)}`;
    document.getElementById(`cpCur${slot}`).innerText = `$${fmt(s.curValUsd, 0)}`;
}

function renderSmallExposureChart(canvasId, snap, color) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    if(window[canvasId] instanceof Chart) window[canvasId].destroy();
    
    window[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: snap.curvePoints.map(p => p.px),
            datasets: [{
                label: 'Exposure %',
                data: snap.curvePoints.map(p => p.expPct),
                borderColor: color,
                backgroundColor: color + '22',
                borderWidth: 2,
                fill: true,
                pointRadius: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
                x: { display: true, ticks: { maxTicksLimit: 5, color: '#666' } },
                y: { display: true, grid: { color: '#1a2433' } }
            }
        }
    });
}

function calculateCrossPair() {
    if(!crossState.A || !crossState.B) { alert("Please capture both Asset A (Base) and Asset B (Quote) first."); return; }
    
    const A = crossState.A; 
    const B = crossState.B; 
    
    if(A.usdPrice <= 0) A.usdPrice = (A.p0 * A.denomUsd) || 1;
    if(B.usdPrice <= 0) B.usdPrice = (B.p0 * B.denomUsd) || 1;

    const impPrice = (Number(A.usdPrice) / Number(B.usdPrice));
    const impMin = A.pmin / B.pmax;
    const impMax = A.pmax / B.pmin;
    
    document.getElementById('cpResults').style.display = 'block';
    document.getElementById('titleChartA').innerText = `${A.name} Exposure Plan`;
    document.getElementById('titleChartB').innerText = `${B.name} Exposure Plan`;
    document.getElementById('crossChartTitle').innerText = `${A.name}/${B.name} Price History`;
    
    renderSmallExposureChart('chartA_Exp', A, '#5bb0ff');
    renderSmallExposureChart('chartB_Exp', B, '#17c964');
    
    updateCrossHistory('30');
    
    document.getElementById('resImpPrice').innerText = fmt(impPrice, 6) + ` ${B.name}`;
    document.getElementById('resImpRange').innerText = `${fmt(impMin, 5)} - ${fmt(impMax, 5)}`;
    
    const totalA_USD = A.curValUsd; 
    const totalB_USD = B.curValUsd; 
    
    document.getElementById('resGapUsd').innerText = `${A.name}: $${fmt(totalA_USD,0)} / ${B.name}: $${fmt(totalB_USD,0)}`;
    
    let availA = Math.max(0, totalA_USD);
    let availB = Math.max(0, totalB_USD);
    
    let bias = 'balanced';
    let statusMsg = "Balanced Deployment";
    let color = "#fff";
    let recHtml = "";
    
    const ratio = (availB > 0) ? availA / availB : (availA > 0 ? 999 : 1);
    
    if (availA > 100 && availB > 100) {
        if (ratio > 1.25) { 
            bias = 'sell'; 
            statusMsg = `Inventory Skewed: Heavy ${A.name}`; 
            color = 'var(--accent)';
            recHtml = `<div style="color:var(--muted)">You hold more ${A.name} than ${B.name}. The schedule below allocates the extra ${A.name} to the upper bands (Ask Side) to capture fees while scaling out.</div>`;
        } else if (ratio < 0.8) { 
            bias = 'buy'; 
            statusMsg = `Inventory Skewed: Heavy ${B.name}`; 
            color = 'var(--good)';
            recHtml = `<div style="color:var(--muted)">You hold more ${B.name} than ${A.name}. The schedule below allocates the extra ${B.name} to the lower bands (Bid Side) to capture fees while acquiring ${A.name} on dips.</div>`;
        } else {
            recHtml = `<div style="color:var(--muted)">Balanced Inventory. Distributing evenly across ±3% range for maximum fee capture.</div>`;
        }
    } else {
        recHtml = `<div style="color:var(--muted)">Using available inventory to create market schedule.</div>`;
    }
    
    document.getElementById('resStatus').innerText = statusMsg;
    document.getElementById('resStatus').style.color = color;
    document.getElementById('recBox').innerHTML = recHtml;
    
    generateCrossSchedule(impPrice, availA, availB, bias, A.name, B.name);
}

function generateCrossSchedule(centerPrice, usd_A, usd_B, bias, symA, symB) {
    const tbody = document.querySelector('#crossTable tbody');
    tbody.innerHTML = '';
    
    const bandsAbove = 3;
    const bandsBelow = 3;
    
    const perBandA = usd_A / bandsAbove; 
    const perBandB = usd_B / bandsBelow;    
    
    const bands = [
        { pct: -3, type: 'Below' }, { pct: -2, type: 'Below' }, { pct: -1, type: 'Below' },
        { pct: 0, type: 'Above' }, { pct: 1, type: 'Above' }, { pct: 2, type: 'Above' }
    ];
    
    const priceA_USD = Number(crossState.A.usdPrice) || 1;
    const priceB_USD = Number(crossState.B.usdPrice) || 1;

    let rows = '';
    bands.forEach(b => {
        const pStart = centerPrice * (1 + b.pct/100);
        const pEnd = centerPrice * (1 + (b.pct+1)/100);
        
        let allocUsd = (b.type === 'Above') ? perBandA : perBandB;
        if (allocUsd < 0.01) return; 
        
        let tokenStr = '';
        const rowColor = b.type === 'Below' ? 'var(--good)' : 'var(--accent)';
        const arrow = b.type === 'Below' ? '↓' : '↑';
        
        if(b.type === 'Below') {
            const tokenAmt = allocUsd / priceB_USD;
            tokenStr = `<td>-</td><td style="font-weight:600; color:${rowColor}">${fmt(tokenAmt, 4)} ${symB}</td>`;
        } else {
            const tokenAmt = allocUsd / priceA_USD;
            tokenStr = `<td style="font-weight:600; color:${rowColor}">${fmt(tokenAmt, 4)} ${symA}</td><td>-</td>`;
        }

        rows += `<tr>
            <td style="color:${rowColor}">${arrow} ${Math.abs(b.pct)}%</td>
            <td>${fmt(pStart, 6)} - ${fmt(pEnd, 6)}</td>
            <td style="color:${rowColor}">${b.type}</td>
            ${tokenStr}
            <td style="color:#aaa">$${fmt(allocUsd, 2)}</td>
        </tr>`;
    });
    
    if(rows === '') rows = '<tr><td colspan="5" style="text-align:center; color:var(--muted); padding:12px;">No deployable capital found. Check "Capture Base/Quote" inputs.</td></tr>';
    tbody.innerHTML = rows;
}

// --- FIX 2: CROSS CHART HISTORY (ROBUST LINEAR MERGE + DELAY) ---
async function updateCrossHistory(days) {
    if(!crossState.A || !crossState.B) return;
    
    document.querySelectorAll('.time-btns button').forEach(b => {
        b.classList.remove('active');
        if(b.textContent.toLowerCase().includes(days === '30' ? '1m' : (days === '365' ? '1y' : 'max'))) b.classList.add('active');
    });

    let idA = COINGECKO_IDS[crossState.A.name.toUpperCase()] || crossState.A.name.toLowerCase();
    let idB = COINGECKO_IDS[crossState.B.name.toUpperCase()] || crossState.B.name.toLowerCase();
    
    // Explicit Fix for BNB/SOL
    if(crossState.B.name.toUpperCase() === 'BNB') idB = 'binancecoin';
    if(crossState.A.name.toUpperCase() === 'BNB') idA = 'binancecoin';
    if(crossState.B.name.toUpperCase() === 'SOL') idB = 'solana';
    if(crossState.A.name.toUpperCase() === 'SOL') idA = 'solana';

    const getUrl = (id, d) => (window.location.hostname === 'localhost' || window.location.protocol === 'file:') ? 
        `https://api.coingecko.com/api/v3/coins/${id}/market_chart?vs_currency=usd&days=${d}` : 
        `/api/history?id=${id}&days=${d}`;
    
    try {
        const chartStatus = document.getElementById('chartStatus');
        if(chartStatus) { chartStatus.style.display = 'block'; chartStatus.innerText = "Loading..."; }

        // Sequential Fetch to avoid Rate Limit (429)
        let dataA, dataB;
        try {
             const resA = await fetch(getUrl(idA, days));
             if(!resA.ok) throw new Error("A failed");
             dataA = await resA.json();
             
             await new Promise(r => setTimeout(r, 600)); // Small delay for robustness
             
             const resB = await fetch(getUrl(idB, days));
             if(!resB.ok) throw new Error("B failed");
             dataB = await resB.json();
        } catch(e) {
             console.warn("Fetch failed", e);
             if(chartStatus) chartStatus.innerText = "API Error (Rate Limit)";
             return;
        }

        if(!dataA.prices || !dataB.prices) throw new Error("Missing history data");
        
        const crossPoints = [];
        const bPrices = dataB.prices; 
        const bLen = bPrices.length;
        
        // O(N) Linear Merge Algorithm
        let bIdx = 0;
        dataA.prices.forEach(ptA => {
             const tA = ptA[0];
             const pA = ptA[1];
             
             // Move bIdx forward until it's just before or at tA
             while (bIdx < bLen - 1 && bPrices[bIdx+1][0] <= tA) {
                 bIdx++;
             }
             
             // Check current vs next to find closest
             let bestIdx = bIdx;
             if (bIdx < bLen - 1) {
                 const diff1 = Math.abs(bPrices[bIdx][0] - tA);
                 const diff2 = Math.abs(bPrices[bIdx+1][0] - tA);
                 if (diff2 < diff1) bestIdx = bIdx + 1;
             }
             
             // 24h Tolerance (matches daily data points)
             if (Math.abs(bPrices[bestIdx][0] - tA) < 86400000) {
                 crossPoints.push({ x: tA, y: pA / bPrices[bestIdx][1] });
             }
        });
        
        if(crossPoints.length > 0) {
            document.getElementById('chartStatus').style.display = 'none';
            renderCrossPriceChart(crossPoints, crossState.A.name, crossState.B.name);
        } else { throw new Error("No overlap"); }
    } catch(e) { 
        const chartStatus = document.getElementById('chartStatus');
        if(chartStatus) chartStatus.innerText = "Chart Unavailable";
    }
}

function renderCrossPriceChart(data, symA, symB) {
    const ctx = document.getElementById('crossPriceChart').getContext('2d');
    if(window.crossChart instanceof Chart) window.crossChart.destroy();
    
    const labels = data.map(d => new Date(d.x).toLocaleDateString());
    const values = data.map(d => d.y);
    const first = values[0], last = values[values.length-1];
    const change = ((last - first)/first)*100;
    const color = change >= 0 ? '#17c964' : '#ff5d5d';
    
    window.crossChart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ data: values, borderColor: color, borderWidth: 2, pointRadius: 0, tension: 0.1 }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, title: { display: true, text: `Ratio: ${fmt(last, 6)} (${change>0?'+':''}${fmt(change,2)}%)`, color: color, font: { size: 14 } } }, scales: { x: { display: false }, y: { position: 'right', grid: { color: '#1a2433' }, ticks: { color: '#666' } } } }
    });
}

// --- SINGLE CHART FUNCTIONS (Unchanged) ---
function renderExposureChart(rows, denomSym, assetSym, p0) {
    const canvasId = 'exposureChart';
    const oldCanvas = document.getElementById(canvasId);
    if(!oldCanvas) return;
    const labels = rows.map(r => r.pricePair);
    const dataExp = rows.map(r => r.expPct);
    const dataUsdPrice = rows.map(r => r.priceUsd);
    
    if(window.mainExpChart instanceof Chart) window.mainExpChart.destroy();

    window.mainExpChart = new Chart(oldCanvas, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label: 'Net Exposure %', data: dataExp, borderColor: '#5bb0ff', backgroundColor: 'rgba(91, 176, 255, 0.1)', yAxisID: 'y', borderWidth: 2, pointRadius: 0, fill: true, tension: 0.2 },
                { label: `${assetSym} Price (USD)`, data: dataUsdPrice, borderColor: '#17c964', borderDash: [5, 5], yAxisID: 'y1', borderWidth: 1.5, pointRadius: 0, tension: 0.1 }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
            plugins: { tooltip: { backgroundColor: '#101620', titleColor: '#fff', bodyColor: '#ccc', borderColor: '#333', borderWidth: 1 }, legend: { labels: { color: '#9fb1c7' } } },
            scales: {
                x: { type: 'linear', display: true, title: { display: true, text: `Price (${assetSym}/${denomSym})`, color: '#555' }, grid: { color: '#1a2433' }, ticks: { color: '#9fb1c7' } },
                y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Net Exposure (%)', color: '#5bb0ff' }, grid: { color: '#1a2433' }, ticks: { color: '#5bb0ff' } },
                y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: 'Price (USD)', color: '#17c964' }, grid: { drawOnChartArea: false }, ticks: { color: '#17c964', callback: function(value) { return '$' + value; } } }
            },
            animation: {
                onComplete: function(animation) {
                    const ctx = animation.chart.ctx;
                    const xAxis = animation.chart.scales.x;
                    const yAxis = animation.chart.scales.y;
                    const xVal = p0;
                    if(xVal >= xAxis.min && xVal <= xAxis.max) {
                        const xPix = xAxis.getPixelForValue(xVal);
                        ctx.save(); ctx.beginPath(); ctx.moveTo(xPix, yAxis.top); ctx.lineTo(xPix, yAxis.bottom);
                        ctx.lineWidth = 1; ctx.strokeStyle = '#ffffff'; ctx.setLineDash([2, 4]); ctx.stroke(); ctx.restore();
                        ctx.fillStyle = '#fff'; ctx.fillText('P₀', xPix + 4, yAxis.top + 10);
                    }
                }
            }
        }
    });
}

async function fetchAndRenderHistory(days, pmin, pmax, portfolioSize, targetMinPct, targetMaxPct, distMode, assetSym, denomSym, denomUsd) {
    const container = document.getElementById('historyChartContainer');
    if(!container) return;
    const activeBelowPct = Number(document.getElementById('activeUtilBelow').value) || 0;
    const activeAbovePct = Number(document.getElementById('activeUtilAbove').value) || 0;
    const aprPct = Number(document.getElementById('aprPct').value) || 0;
    const activeRatio = (activeBelowPct + activeAbovePct) / 200; 
    
    container.innerHTML = `<div style="color:var(--muted); padding:20px; text-align:center;">Fetching ${days}-day history...</div>`;
    let assetId = COINGECKO_IDS[assetSym] || assetSym.toLowerCase();
    
    const getUrl = (id, d) => (window.location.hostname === 'localhost' || window.location.protocol === 'file:') ? `https://api.coingecko.com/api/v3/coins/${id}/market_chart?vs_currency=usd&days=${d}` : `/api/history?id=${id}&days=${d}`;
    
    let prices = [];
    try {
        let res = await fetch(getUrl(assetId, days));
        if(!res.ok) throw new Error("Failed to fetch history");
        const data = await res.json();
        prices = data.prices; 
    } catch(e) {
        container.innerHTML = `<div style="color:var(--bad); padding:20px; text-align:center;">History Load Error: ${e.message}<br><span style="font-size:10px; color:var(--muted)">Check CORS or Proxy settings</span></div>`;
        return;
    }
    
    let cumPnL = 0; let cumYield = 0; let cumYieldPnL = 0;
    const histData = prices.map((p, idx) => {
        const timestamp = p[0];
        const date = new Date(timestamp).toLocaleDateString(undefined, {month:'numeric', day:'numeric'});
        const priceUsd = p[1];
        const pairPrice = priceUsd / (denomUsd > 0 ? denomUsd : 1);
        const units = getUnitsHeldAt(pairPrice, pmin, pmax, portfolioSize, targetMinPct, targetMaxPct, distMode);
        
        if(idx > 0) {
            const prevPrice = prices[idx-1][1] / (denomUsd > 0 ? denomUsd : 1);
            const prevUnits = getUnitsHeldAt(prevPrice, pmin, pmax, portfolioSize, targetMinPct, targetMaxPct, distMode);
            const priceDelta = pairPrice - prevPrice;
            const stepPnL = priceDelta * prevUnits;
            cumPnL += stepPnL;
            const dt = (timestamp - prices[idx-1][0]) / (1000 * 60 * 60 * 24);
            const activeCap = portfolioSize * activeRatio; 
            const stepYield = activeCap * (aprPct/100) * (dt/365);
            cumYield += stepYield;
            cumYieldPnL = cumPnL + cumYield;
        }
        const expDenom = units * pairPrice;
        const expPct = (portfolioSize > 0) ? (expDenom / portfolioSize) * 100 : 0;
        return { x: date, price: priceUsd, expPct, pnl: cumPnL, totalPnl: cumYieldPnL };
    });
    
    container.innerHTML = `<div style="margin-bottom:12px;"><canvas id="historyExpChart" height="200"></canvas></div><div><canvas id="historyPnlChart" height="200"></canvas></div>`;
    new Chart(document.getElementById('historyExpChart'), {
        type: 'line', data: { labels: histData.map(d => d.x), datasets: [{ label: 'Simulated Exposure %', data: histData.map(d => d.expPct), borderColor: '#5bb0ff', borderWidth: 2, yAxisID: 'yExp', pointRadius: 0, tension: 0.2 }, { label: 'Price (USD)', data: histData.map(d => d.price), backgroundColor: 'rgba(23, 201, 100, 0.1)', borderColor: '#17c964', borderWidth: 1, fill: true, yAxisID: 'yPrice', pointRadius: 0, tension: 0.2 }] },
        options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, scales: { x: { display:false }, yExp: { type: 'linear', display: true, position: 'left', grid: { color: '#1a2433' } }, yPrice: { type: 'linear', display: true, position: 'right', grid: { display: false } } }, plugins: { title: { display: true, text: 'Historical Exposure Check', color: '#9fb1c7' } } }
    });
    new Chart(document.getElementById('historyPnlChart'), {
        type: 'line', data: { labels: histData.map(d => d.x), datasets: [{ label: `Strategy PnL (${denomSym})`, data: histData.map(d => d.pnl), borderColor: '#e08aff', borderWidth: 2, pointRadius: 0, tension: 0.2 }, { label: `Total PnL w/ Yield (${denomSym})`, data: histData.map(d => d.totalPnl), borderColor: '#ffe600', borderDash: [4,4], borderWidth: 2, pointRadius: 0, tension: 0.2 }] },
        options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, scales: { x: { ticks: { maxTicksLimit: 10, color: '#666' } }, y: { grid: { color: '#1a2433' }, title: { display:true, text:`PnL (${denomSym})` } } }, plugins: { title: { display: true, text: `Strategy Profit Simulation (APR: ${aprPct}%)`, color: '#9fb1c7' } } }
    });
}

function updateBacktest(daysStr) {
   const pmin = Number(document.getElementById('pmin').value);
   const pmax = Number(document.getElementById('pmax').value);
   const portfolioSize = Number(document.getElementById('portfolioSize').value);
   const targetMinPct = Number(document.getElementById('targetMinPct').value);
   const targetMaxPct = Number(document.getElementById('targetMaxPct').value);
   const distMode = document.getElementById('distMode').value;
   const assetSym = (document.getElementById('assetSelect').value || 'ALT').toUpperCase();
   const denomSym = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
   const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
   
   document.querySelectorAll('.time-btns button').forEach(b => {
       b.classList.remove('active');
       if(b.textContent.toLowerCase() === daysStr.toLowerCase() || (daysStr==='max' && b.textContent==='MAX')) b.classList.add('active');
   });
   
   fetchAndRenderHistory(daysStr, pmin, pmax, portfolioSize, targetMinPct, targetMaxPct, distMode, assetSym, denomSym, denomUsd);
}

function generateExposureSchedule() {
  const container = document.getElementById('resultsContainer'); container.innerHTML = '';
  const pmin = Number(document.getElementById('pmin').value), pmax = Number(document.getElementById('pmax').value), stepPct = Number(document.getElementById('intervalPct').value) || 1;
  const p0 = Number(document.getElementById('p0').value);
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0, portfolioSize = Number(document.getElementById('portfolioSize').value) || 0;
  const targetMinPct = Number(document.getElementById('targetMinPct').value) || 0, targetMaxPct = Number(document.getElementById('targetMaxPct').value) || 0;
  const distMode = document.getElementById('distMode').value;
  const assetSym = (document.getElementById('assetSelect').value || 'ALT').toUpperCase(), denomSym = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
  
  if (pmin <= 0 || pmax <= pmin || portfolioSize <= 0) return;
  const rows = [];
  let p = pmin;
  while(p <= pmax * (1 + stepPct/100)) { 
    const currentPrice = p;
    const units = getUnitsHeldAt(currentPrice, pmin, pmax, portfolioSize, targetMinPct, targetMaxPct, distMode);
    const netExpDenom = units * currentPrice;
    const netExpPct = (netExpDenom / portfolioSize) * 100;
    const netExpUsd = netExpDenom * denomUsd;
    const priceUsd = currentPrice * denomUsd;
    rows.push({ pricePair: currentPrice, priceUsd: priceUsd, expPct: netExpPct, expDenom: netExpDenom, expUsd: netExpUsd });
    if(p >= pmax) break; p = p * (1 + stepPct/100); if(p > pmax && p < pmax * 1.01) p = pmax; 
  }
  
  const html = `
    <div class="layout-grid">
        <div>
            <div class="section-header">Exposure Profile</div>
            <div class="card"><div class="chart-container" style="height:350px;"><canvas id="exposureChart"></canvas></div></div>
        </div>
        <div>
            <div class="section-header" style="justify-content:space-between;"><span>Backtest vs History</span></div>
            <div class="card">
                <div class="time-btns">
                    <button class="secondary" onclick="updateBacktest('30')">30D</button>
                    <button class="secondary" onclick="updateBacktest('90')">3M</button>
                    <button class="secondary" onclick="updateBacktest('180')">6M</button>
                    <button class="secondary" onclick="updateBacktest('365')">1Y</button>
                    <button class="secondary" onclick="updateBacktest('max')">MAX</button>
                </div>
                <div class="chart-container" id="historyChartContainer" style="position:relative; height:420px;"><div style="padding:20px; color:var(--muted); text-align:center;">Select timeframe to load</div></div>
            </div>
        </div>
    </div>
    <div class="section-header">Detailed Schedule</div>
    <div class="card"><div class="scroll"><table><thead><tr><th style="text-align:left">Price (${assetSym}/${denomSym})</th><th>Price (${assetSym}/USD)</th><th>Net Exposure (Port %)</th><th>Net Exposure (${denomSym})</th><th>Net Exposure (USD)</th></tr></thead>
    <tbody>${rows.map(r => `<tr><td style="text-align:left; color:var(--accent);">${fmt(r.pricePair, 8)}</td><td>$${fmt(r.priceUsd, 2)}</td><td style="color:${r.expPct >= 0 ? 'var(--good)' : 'var(--bad)'}">${fmt(r.expPct, 2)}%</td><td>${fmt(r.expDenom, 4)}</td><td>$${fmt(r.expUsd, 2)}</td></tr>`).join('')}</tbody></table></div></div>`;
  const div = document.createElement('div'); div.innerHTML = html; container.appendChild(div);
  
  setTimeout(() => { renderExposureChart(rows, denomSym, assetSym, p0); updateBacktest('30'); }, 100);
}

function generatePnLSchedule() {
  const container = document.getElementById('resultsContainer'); container.innerHTML = '';
  const pmin = Number(document.getElementById('pmin').value);
  const pmax = Number(document.getElementById('pmax').value);
  const p0 = Number(document.getElementById('p0').value);
  const stepPct = Number(document.getElementById('intervalPct').value) || 1;
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  const portfolioSize = Number(document.getElementById('portfolioSize').value) || 0;
  const targetMinPct = Number(document.getElementById('targetMinPct').value) || 0;
  const targetMaxPct = Number(document.getElementById('targetMaxPct').value) || 0;
  const currentE = Number(document.getElementById('currentE').value) || 0;
  const distMode = document.getElementById('distMode').value;
  const scaleMode = document.getElementById('scaleMode').value;
  const aprPct = Number(document.getElementById('aprPct').value) || 0;
  const activeBelowPct = Number(document.getElementById('activeUtilBelow').value) || 0;
  const activeAbovePct = Number(document.getElementById('activeUtilAbove').value) || 0;
  const assetSym = (document.getElementById('assetSelect').value || 'ALT').toUpperCase();
  const denomSym = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
  
  if (pmin <= 0 || pmax <= pmin || portfolioSize <= 0 || p0 <= 0) return;
  
  const isDual = document.getElementById('dualLpMode').checked;
  const isJlpMode = document.getElementById('jlpStrategyMode').checked;
  let capitalRatio = isDual ? (Number(document.getElementById('dualMult').value) || 0.5) : (isJlpMode ? 0.5 : 1.0);
  
  const strategyParams = { pmin, pmax, p0, stepPct, portfolioSize: portfolioSize * capitalRatio, currentE: currentE * capitalRatio, targetMinPct, targetMaxPct, denomSymbol: denomSym, denomUsd, assetSymbol: assetSym, scaleMode: document.getElementById('scaleMode').value, aprPct: 0, maxDays: 0, distMode };
  const stratData = calculateStrategy(strategyParams);
  if (!stratData || !stratData.kpi) return;
  
  const stratCapBelow = stratData.kpi.belowTotal;
  const stratCapAbove = stratData.kpi.aboveTotal;
  const stratCapTotal = stratCapBelow + stratCapAbove;
  const activeCapBelow = stratCapBelow * (activeBelowPct / 100);
  const activeCapAbove = stratCapAbove * (activeAbovePct / 100);
  const totalActiveCap = activeCapBelow + activeCapAbove;
  const dailyYield = (totalActiveCap * (aprPct / 100)) / 365;
  const effectiveGlobalApr = stratCapTotal > 0 ? ((dailyYield * 365) / stratCapTotal) * 100 : 0;
  
  let rawPrices = [p0]; let p = pmin;
  while(p <= pmax * (1 + stepPct/100)) { rawPrices.push(p); p = p * (1 + stepPct/100); if(p > pmax && p < pmax * 1.01) p = pmax; }
  rawPrices = [...new Set(rawPrices)].sort((a,b) => a - b);
  const startIdx = rawPrices.indexOf(p0);
  const points = rawPrices.map(px => {
      const units = getUnitsHeldAt(px, pmin, pmax, portfolioSize, targetMinPct, targetMaxPct, distMode);
      return { px: px, units: units, expDenom: units * px };
  });
  points[startIdx].pnl = 0;
  for(let i = startIdx + 1; i < points.length; i++) { const prev = points[i-1], curr = points[i]; curr.pnl = prev.pnl + ((prev.units + curr.units) / 2 * (curr.px - prev.px)); }
  for(let i = startIdx - 1; i >= 0; i--) { const prev = points[i+1], curr = points[i]; curr.pnl = prev.pnl + ((prev.units + curr.units) / 2 * (curr.px - prev.px)); }
  
  const html = `
    <div class="section-header">Projected PnL Schedule</div>
    <div class="summary-box">
       <div class="summary-row">
          <div class="summary-item"><label>Total Strategy Capital</label><div>${fmt(stratCapTotal, 4)} ${denomSym}</div></div>
          <div class="summary-item"><label>Active Capital (Deployed)</label><div style="color:var(--accent)">${fmt(totalActiveCap, 4)} ${denomSym}</div></div>
          <div class="summary-item"><label>Daily Yield (${aprPct}%)</label><div style="color:var(--good)">${fmt(dailyYield, 5)} ${denomSym}</div></div>
          <div class="summary-item"><label>Effective Global APR</label><div>${fmt(effectiveGlobalApr, 2)}%</div></div>
       </div>
       <div style="font-size:11px; color:var(--muted); margin-top:5px;">
         Active Below: ${fmt(activeCapBelow, 4)} ${denomSym} (${activeBelowPct}%) &nbsp;|&nbsp; 
         Active Above: ${fmt(activeCapAbove, 4)} ${denomSym} (${activeAbovePct}%)
       </div>
    </div>
    <div class="card"><div class="scroll"><table><thead><tr><th style="text-align:left">Price (${assetSym}/${denomSym})</th><th>Target Exp (${denomSym})</th><th>PnL (${denomSym})</th><th>PnL (USD)</th><th>Days to Break Even</th></tr></thead><tbody>${points.map(r => {
       const isP0 = Math.abs(r.px - p0) < 1e-9;
       let daysStr = (r.pnl < 0 && dailyYield > 0) ? (Math.abs(r.pnl)/dailyYield).toFixed(1) + ' d' : '–';
       const pnlColor = r.pnl >= 0 ? 'var(--good)' : 'var(--bad)';
       return `<tr style="${isP0 ? 'background:rgba(255,255,255,0.05);' : ''}"><td style="text-align:left; color:${isP0?'var(--accent)':'inherit'}">${fmt(r.px, 8)} ${isP0?'(P₀)':''}</td><td>${fmt(r.expDenom, 4)}</td><td style="color:${pnlColor}; font-weight:600;">${r.pnl>0?'+':''}${fmt(r.pnl, 5)}</td><td style="color:${pnlColor}">${r.pnl>0?'+':''}$${fmt(r.pnl * denomUsd, 2)}</td><td style="color:var(--warn);">${daysStr}</td></tr>`;
    }).join('')}</tbody></table></div></div>`;
  const div = document.createElement('div'); div.innerHTML = html; container.appendChild(div);
}

(function(){
  const assetSel = document.getElementById('assetSelect'), denomSel = document.getElementById('denomSelect');
  const altUsdEl = document.getElementById('altUsd'), denomUsdEl = document.getElementById('denomUsd'), p0El = document.getElementById('p0');
  
  if(document.getElementById('btn')) document.getElementById('btn').addEventListener('click', generate);
  document.getElementById('btnCaptureA').addEventListener('click', () => captureSnapshot('A'));
  document.getElementById('btnCaptureB').addEventListener('click', () => captureSnapshot('B'));
  document.getElementById('btnCalcCross').addEventListener('click', calculateCrossPair);
  if(document.getElementById('btnClear')) document.getElementById('btnClear').addEventListener('click', function(){ document.getElementById('resultsContainer').innerHTML = ''; });
  
  const btnExp = document.getElementById('btnExposure');
  if(btnExp) btnExp.addEventListener('click', generateExposureSchedule);
  const btnPnL = document.getElementById('btnPnL');
  if(btnPnL) btnPnL.addEventListener('click', generatePnLSchedule);

  if(altUsdEl) altUsdEl.addEventListener('input', updateP0FromUsd);
  if(denomUsdEl) denomUsdEl.addEventListener('input', updateP0FromUsd);
  if(p0El) p0El.addEventListener('input', updateUsdFromP0);
  if (assetSel) assetSel.addEventListener('change', () => loadAssetConfig(assetSel.value));
  if (denomSel) denomSel.addEventListener('change', () => {
      updateDenomLabels(denomSel.value);
      autoFetchPrices(assetSel ? assetSel.value : '', denomSel.value);
  });
  ['portfolioSize', 'targetMinPct', 'targetMaxPct'].forEach(id => {
      const el = document.getElementById(id);
      if(el) el.addEventListener('input', updateAutoTargets);
  });
  loadAssetList();
  if (denomSel) autoFetchPrices('', denomSel.value);
})();
</script>
</body>
</html>
