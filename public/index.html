<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LP Exposure Planner</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#101826;
    --panel2:#0f1724;
    --text:#dbe7ff;
    --muted:#7f94b5;
    --accent:#52a7ff;
    --good:#4ee6a5;
    --bad:#ff5a73;
    --warn:#ffcc66;
    --line:#1c2a42;
  }
  html,body{height:100%;}
  body{
    margin:0; font:13px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:radial-gradient(1200px 600px at 20% 10%, rgba(82,167,255,.18), transparent 55%),
               radial-gradient(900px 500px at 80% 30%, rgba(78,230,165,.12), transparent 60%),
               var(--bg);
    color:var(--text);
  }
  header{
    padding:16px 18px;
    border-bottom:1px solid var(--line);
    background:linear-gradient(180deg, rgba(16,24,38,.95), rgba(16,24,38,.65));
    position:sticky; top:0; z-index:10;
    backdrop-filter: blur(6px);
  }
  header h1{margin:0; font-size:16px; font-weight:700; letter-spacing:.2px;}
  header .sub{margin-top:4px; color:var(--muted); font-size:12px;}
  main{padding:18px; max-width:1180px; margin:0 auto;}
  .grid{
    display:grid; gap:14px;
    grid-template-columns: 1.3fr .9fr;
  }
  @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }
  .card{
    border:1px solid var(--line);
    border-radius:12px;
    background:linear-gradient(180deg, rgba(16,24,38,.75), rgba(15,23,36,.6));
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .card .hd{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
    display:flex; align-items:center; justify-content:space-between;
    gap:12px;
  }
  .card .hd h2{
    margin:0; font-size:13px; font-weight:800; letter-spacing:.25px; text-transform:uppercase;
    color:#cfe3ff;
  }
  .card .bd{padding:14px;}
  .row { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
  .row2 { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  .row4 { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
  .row5 { display:grid; grid-template-columns:repeat(5,1fr); gap:8px; }
  .field{
    display:flex; flex-direction:column; gap:4px;
  }
  label{
    font-size:11px; color:var(--muted);
  }
  input, select, textarea{
    background:rgba(10,15,22,.65);
    color:var(--text);
    border:1px solid rgba(28,42,66,.9);
    border-radius:9px;
    padding:8px 10px;
    outline:none;
    transition: border-color .15s ease, box-shadow .15s ease;
  }
  input:focus, select:focus, textarea:focus{
    border-color: rgba(82,167,255,.75);
    box-shadow: 0 0 0 3px rgba(82,167,255,.12);
  }
  input[readonly]{
    opacity:.85;
    background:rgba(10,15,22,.35);
  }
  .btnbar{display:flex; gap:8px; flex-wrap:wrap;}
  button{
    border:1px solid rgba(28,42,66,.9);
    background:linear-gradient(180deg, rgba(82,167,255,.18), rgba(82,167,255,.06));
    color:var(--text);
    border-radius:10px;
    padding:9px 12px;
    font-weight:700;
    cursor:pointer;
    transition: transform .05s ease, background .15s ease, border-color .15s ease;
  }
  button:hover{border-color: rgba(82,167,255,.75);}
  button:active{transform: translateY(1px);}
  .ghost{
    background:rgba(255,255,255,.03);
  }
  .danger{
    background:linear-gradient(180deg, rgba(255,90,115,.15), rgba(255,90,115,.06));
    border-color: rgba(255,90,115,.35);
  }
  .pill{
    font-size:11px;
    padding:3px 8px;
    border-radius:999px;
    border:1px solid rgba(28,42,66,.9);
    background:rgba(255,255,255,.03);
    color:var(--muted);
    white-space:nowrap;
  }
  .pill.good{border-color: rgba(78,230,165,.55); color: rgba(78,230,165,.95);}
  .pill.warn{border-color: rgba(255,204,102,.55); color: rgba(255,204,102,.95);}
  .pill.bad{border-color: rgba(255,90,115,.55); color: rgba(255,90,115,.95);}
  .muted{color:var(--muted);}
  .sep{height:1px; background:var(--line); margin:12px 0;}
  table{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
  }
  th, td{
    padding:8px 8px;
    border-bottom:1px solid rgba(28,42,66,.75);
    text-align:right;
    white-space:nowrap;
  }
  th{
    color:var(--muted);
    font-weight:800;
    text-transform:uppercase;
    font-size:11px;
    letter-spacing:.25px;
  }
  td:first-child, th:first-child{ text-align:left; }
  .small{font-size:11px;}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  .tag{
    display:inline-block;
    padding:2px 6px;
    border-radius:999px;
    font-size:10px;
    border:1px solid rgba(28,42,66,.9);
    color:var(--muted);
    background:rgba(255,255,255,.03);
  }
  .tag.hold{border-color: rgba(82,167,255,.55); color: rgba(82,167,255,.95);}
  .tag.source{border-color: rgba(255,204,102,.55); color: rgba(255,204,102,.95);}
  .right{display:flex; gap:8px; align-items:center;}
  .hint{
    color:var(--muted);
    font-size:11px;
    margin-top:8px;
  }
  .note{
    color:var(--muted);
    font-size:12px;
    padding:10px 12px;
    border-radius:10px;
    border:1px dashed rgba(28,42,66,.9);
    background:rgba(255,255,255,.02);
  }
  .kbd{font:11px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    padding:2px 6px; border-radius:7px; border:1px solid rgba(28,42,66,.9); background:rgba(255,255,255,.03); color:var(--muted);}
</style>
</head>
<body>
<header>
  <h1>LP Exposure Planner</h1>
  <div class="sub">Plan net exposure schedules above/below a mid-price, with optional scaling and target clamps.</div>
</header>

<main>
  <div class="grid">

    <!-- Left: Inputs -->
    <section class="card">
      <div class="hd">
        <h2>Inputs</h2>
        <div class="right">
          <span class="pill" id="envPill">Local</span>
          <span class="pill good" id="pricePill">Price OK</span>
        </div>
      </div>
      <div class="bd">
        <div class="row4">
          <div class="field">
            <label>Asset (Numerator)</label>
            <select id="assetSelect"></select>
          </div>
          <div class="field">
            <label>Denom (Denominator)</label>
            <select id="denomSelect">
              <option value="BTC">BTC</option>
              <option value="USDT">USDT</option>
              <option value="USDC">USDC</option>
              <option value="USD">USD</option>
              <option value="ETH">ETH</option>
            </select>
          </div>
          <div class="field">
            <label>ALT/USD <span class="muted">(auto)</span></label>
            <input id="altUsd" type="number" step="0.0001" value="0"/>
          </div>
          <div class="field">
            <label><span class="denomLabel">BTC</span>/USD <span class="muted">(auto)</span></label>
            <input id="denomUsd" type="number" step="0.0001" value="0"/>
          </div>
        </div>

        <div class="sep"></div>

        <div class="row4">
          <div class="field">
            <label>P₀ (ALT/<span class="denomLabelShort">BTC</span>) <span class="muted">(auto = ALT/USD ÷ denom/USD)</span></label>
            <input id="p0" type="number" step="0.00000001" value="0"/>
          </div>
          <div class="field">
            <label>Pmin</label>
            <input id="pmin" type="number" step="0.00000001" value="0"/>
          </div>
          <div class="field">
            <label>Pmax</label>
            <input id="pmax" type="number" step="0.00000001" value="0"/>
          </div>
          <div class="field">
            <label>Max bands per side</label>
            <input id="maxBands" type="number" step="1" value="50"/>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div class="field">
            <label>Portfolio size (<span class="denomLabelShort">BTC</span>)</label>
            <input id="portfolioSize" type="number" step="0.0001" value="0"/>
          </div>
          <div class="field">
            <label>Target @ Pmin (%)</label>
            <input id="targetMinPct" type="number" step="0.01" value="50"/>
          </div>
          <div class="field">
            <label>Target @ Pmax (%)</label>
            <input id="targetMaxPct" type="number" step="0.01" value="150"/>
          </div>
          <div class="field">
            <label>Distribution</label>
            <select id="distMode">
              <option value="uniform">Uniform (Equal quote below / equal units above)</option>
              <option value="univ3">Uniswap V3 (Constant liquidity)</option>
            </select>
          </div>
        </div>

        <div class="row5" style="margin-top:6px;">
          <div>
            <label>Interval size (%)</label>
            <input type="number" id="intervalPct" step="0.01" value="1">
          </div>
          <div style="position:relative;">
            <label>Current Net Exposure (<span class="denomLabelShort">BTC</span>)
              <span class="muted">(ALT + short, before LP)</span>
            </label>
            <div style="display:flex; gap:4px;">
              <input type="number" id="currentE" step="0.0001" value="0" style="flex:1;">
              <span id="fetchIndicator" style="display:none; color:var(--accent); font-size:10px; align-self:center;">Updating...</span>
            </div>
            <div id="fetchStatus" style="font-size:10px; color:var(--warn); margin-top:2px; height:14px;"></div>
            <div id="p0DeltaLine" style="font-size:10px; color:var(--muted); margin-top:2px; height:14px;"></div>
          </div>
          <div>
            <label>Target @ P₀ (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetP0" step="0.0001" value="0" readonly>
          </div>
          <div>
            <label>Target @ Pmin (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetMin" step="0.0001" value="0" readonly>
          </div>
          <div>
            <label>Target @ Pmax (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="targetMax" step="0.0001" value="0" readonly>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div>
            <label>Denom Current Net Exposure (<span class="denomLabelShort">BTC</span>, auto)</label>
            <input type="number" id="denomCurrentE" step="0.0001" value="0" readonly>
            <div id="denomFetchStatus" style="font-size:10px; color:var(--muted); margin-top:2px; height:14px;"></div>
          </div>
          <div>
            <label>Denom Target Exposure (<span class="denomLabelShort">BTC</span>, manual)</label>
            <input type="number" id="denomTargetE" step="0.0001" value="0">
          </div>
          <div>
            <label>Denom Δ vs Target (<span class="denomLabelShort">BTC</span>)</label>
            <input type="number" id="denomDeltaE" step="0.0001" value="0" readonly>
          </div>
          <div>
            <label>Denom Budget for Below (max spend) (<span class="denomLabelShort">BTC</span>)</label>
            <input type="number" id="denomBudget" step="0.0001" value="0" readonly>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div class="field">
            <label>Precision decimals</label>
            <input type="number" id="dec" value="6"/>
          </div>
          <div class="field">
            <label>Capital ratio</label>
            <input type="number" id="capitalRatio" step="0.01" value="1"/>
          </div>
          <div class="field">
            <label>Scale exposure with price?</label>
            <select id="scaleMode">
              <option value="scale">Yes (value scales linearly with price)</option>
              <option value="noscale">No (treat net exposure constant in denom terms)</option>
            </select>
          </div>
          <div class="field">
            <label>Schedule mode</label>
            <select id="scheduleMode">
              <option value="single">Single LP</option>
              <option value="dual">Dual LP (Top+Bottom legs)</option>
            </select>
          </div>
        </div>

        <div class="row4" style="margin-top:6px;">
          <div class="field">
            <label>APR % (optional)</label>
            <input type="number" id="aprPct" step="0.01" value="0"/>
          </div>
          <div class="field">
            <label>Max days (optional)</label>
            <input type="number" id="maxDays" step="1" value="0"/>
          </div>
          <div class="field">
            <label>LP2 split % (Dual mode)</label>
            <input type="number" id="lp2SplitPct" step="0.1" value="50"/>
          </div>
          <div class="field">
            <label>LP2 range multiplier (Dual mode)</label>
            <input type="number" id="lp2RangeMult" step="0.1" value="1.5"/>
          </div>
        </div>

        <div class="sep"></div>

        <div class="btnbar">
          <button id="btnFetch">Auto-load Exposure</button>
          <button class="ghost" id="btnAutoPrices">Auto-load Prices</button>
          <button id="btnGen">Generate Schedules</button>
          <button class="danger" id="btnClear">Clear Outputs</button>
        </div>

        <div class="hint">
          Tip: hit <span class="kbd">Auto-load Prices</span> then <span class="kbd">Auto-load Exposure</span>, then generate. Dual mode creates two tables.
        </div>

      </div>
    </section>

    <!-- Right: Outputs -->
    <section class="card">
      <div class="hd">
        <h2>Outputs</h2>
        <div class="right">
          <span class="pill" id="bandsPill">0 bands</span>
          <span class="pill" id="modePill">Uniform</span>
        </div>
      </div>
      <div class="bd">
        <div id="outArea" class="note">No schedules generated yet.</div>
      </div>
    </section>

  </div>
</main>

<script>
/* -------------------------
   Helpers
-------------------------- */
function fmt(x, d=6){
  if(!isFinite(x)) return '';
  return Number(x).toLocaleString(undefined,{minimumFractionDigits:d, maximumFractionDigits:d});
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function safeNum(x, def=0){ x=Number(x); return isFinite(x)?x:def; }

/* -------------------------
   Price fetches
-------------------------- */
async function fetchJson(url){
  const r = await fetch(url);
  if(!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.json();
}

async function autoFetchPrices(assetSym, denomSym){
  try{
    const envPill = document.getElementById('envPill');
    envPill.textContent = location.host.includes('localhost') ? 'Local' : 'Remote';
    const asset = (assetSym||'').toUpperCase();
    const denom = (denomSym||'').toUpperCase();
    if(!denom){
      setPricePill('warn', 'Need denom');
      return;
    }
    // denomUsd
    let denomUsd = 0;
    if(['USD','USDC','USDT'].includes(denom)) denomUsd = 1;
    else{
      try{
        const px = await fetchJson(`/api/prices?pair=${encodeURIComponent(denom)}USD`);
        denomUsd = safeNum(px.price, 0);
      }catch(e){
        // fallback: some APIs use -USDT
        try{
          const px = await fetchJson(`/api/prices?pair=${encodeURIComponent(denom)}USDT`);
          denomUsd = safeNum(px.price, 0);
        }catch(_){ denomUsd=0; }
      }
    }
    document.getElementById('denomUsd').value = denomUsd || 0;

    // altUsd
    if(asset){
      let altUsd = 0;
      try{
        const px2 = await fetchJson(`/api/prices?pair=${encodeURIComponent(asset)}USD`);
        altUsd = safeNum(px2.price, 0);
      }catch(e){
        try{
          const px2 = await fetchJson(`/api/prices?pair=${encodeURIComponent(asset)}USDT`);
          altUsd = safeNum(px2.price, 0);
        }catch(_){ altUsd=0; }
      }
      document.getElementById('altUsd').value = altUsd || 0;
    }

    updateP0FromUsd();
    setPricePill('good', 'Price OK');
  }catch(err){
    console.error(err);
    setPricePill('bad', 'Price fetch failed');
  }
}

function setPricePill(kind, text){
  const pill = document.getElementById('pricePill');
  pill.textContent = text;
  pill.classList.remove('good','warn','bad');
  if(kind==='good') pill.classList.add('good');
  if(kind==='warn') pill.classList.add('warn');
  if(kind==='bad') pill.classList.add('bad');
}

function updateDenomLabels(denomSym){
  const denom = (denomSym||'BTC').toUpperCase();
  const denomLabel = document.querySelectorAll('.denomLabel');
  denomLabel.forEach(el=>el.textContent = denom);
  const denomShort = document.querySelectorAll('.denomLabelShort');
  denomShort.forEach(el=>el.textContent = denom);
}

function updateP0FromUsd(){
  const altUsd = Number(document.getElementById('altUsd').value) || 0;
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  const p0El = document.getElementById('p0');
  if(altUsd>0 && denomUsd>0){
    const ratio = altUsd/denomUsd;
    p0El.value = ratio.toFixed(10);
        updateAutoTargets();
  }
}

function updateUsdFromP0(){
  const p0 = Number(document.getElementById('p0').value) || 0;
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;
  const altUsdEl = document.getElementById('altUsd');
  if(p0>0 && denomUsd>0){
    const val = p0*denomUsd;
    altUsdEl.value = val.toFixed(6);
        updateAutoTargets();
  }
}

/* -------------------------
   Exposure fetch + targets
-------------------------- */
function updateAutoTargets() {
    const portSize = Number(document.getElementById('portfolioSize').value) || 0;
    const minPct = Number(document.getElementById('targetMinPct').value) || 0;
    const maxPct = Number(document.getElementById('targetMaxPct').value) || 0;
    const targetMinEl = document.getElementById('targetMin');
    const targetMaxEl = document.getElementById('targetMax');
    const tMin = portSize * (minPct / 100.0);
    const tMax = portSize * (maxPct / 100.0);
    if(targetMinEl) targetMinEl.value = tMin.toFixed(4);
    if(targetMaxEl) targetMaxEl.value = tMax.toFixed(4);
    updateTargetAtP0();
}

function updateDenomDelta() {
    const curEl = document.getElementById('denomCurrentE');
    const tgtEl = document.getElementById('denomTargetE');
    const deltaEl = document.getElementById('denomDeltaE');
    const budgetEl = document.getElementById('denomBudget');
    if(!curEl || !tgtEl || !deltaEl || !budgetEl) return;
    const cur = Number(curEl.value) || 0;
    const tgt = Number(tgtEl.value) || 0;
    const delta = cur - tgt;
    deltaEl.value = (isFinite(delta) ? delta : 0).toFixed(6);
    budgetEl.value = (isFinite(delta) ? Math.max(0, delta) : 0).toFixed(6);
    deltaEl.style.color = (delta >= 0) ? 'var(--good)' : 'var(--warn)';
    budgetEl.style.color = 'var(--good)';
}

function updateTargetAtP0() {
    const targetP0El = document.getElementById('targetP0');
    if(!targetP0El) return;

    const pmin = Number(document.getElementById('pmin').value);
    const pmax = Number(document.getElementById('pmax').value);
    const p0 = Number(document.getElementById('p0').value);
    const portSize = Number(document.getElementById('portfolioSize').value);
    const tMinPct = Number(document.getElementById('targetMinPct').value);
    const tMaxPct = Number(document.getElementById('targetMaxPct').value);
    const distMode = document.getElementById('distMode').value;
    const denomSym = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();

    let targetExp = 0;
    if(pmin > 0 && pmax > pmin && p0 > 0 && portSize > 0) {
        const units = getUnitsHeldAt(p0, pmin, pmax, portSize, tMinPct, tMaxPct, distMode);
        targetExp = units * p0;
    }
    targetP0El.value = (isFinite(targetExp) ? targetExp : 0).toFixed(4);

    const dec = Number(document.getElementById('dec').value) || 4;
    const currentE = Number(document.getElementById('currentE').value) || 0;
    const delta = currentE - targetExp;
    const deltaLine = document.getElementById('p0DeltaLine');
    if(deltaLine) {
        const sign = delta >= 0 ? '+' : '';
        deltaLine.textContent = `Δ vs Target @ P₀: ${sign}${fmt(delta, dec)} ${denomSym}`;
        if(Math.abs(delta) < 1e-9) deltaLine.style.color = 'var(--muted)';
        else deltaLine.style.color = (delta > 0) ? 'var(--accent)' : 'var(--warn)';
    }

    updateDenomDelta();
}

let autoFetchTimer=null;
function triggerAutoFetch(){
  if(autoFetchTimer) clearTimeout(autoFetchTimer);
  autoFetchTimer = setTimeout(()=>fetchLiveExposure(), 650);
}

async function fetchLiveExposure() {
  const assetSym = document.getElementById('assetSelect').value;
  const denomSym = (document.getElementById('denomSelect').value || 'BTC').toUpperCase();
  const denomUsd = Number(document.getElementById('denomUsd').value || 0);

  const statusEl = document.getElementById('fetchStatus');
  const denomStatusEl = document.getElementById('denomFetchStatus');
  const currentEEl = document.getElementById('currentE');
  const denomCurrentEl = document.getElementById('denomCurrentE');
  const indEl = document.getElementById('fetchIndicator');

  if(!assetSym || assetSym === "") { if(statusEl) statusEl.textContent = ''; return; }
  if(denomUsd <= 0) return;
  if(indEl) indEl.style.display = 'block';
  
  try {
    const res = await fetch('/api/exposure');
    if (!res.ok) throw new Error(`Error ${res.status}`);
    const rawData = await res.json();
    let dataList = [];
    if (Array.isArray(rawData)) { dataList = rawData; } 
    else if (typeof rawData === 'object' && rawData !== null) {
        const keys = Object.keys(rawData);
        if (keys.length > 0 && keys.every(k => k === k.toUpperCase() && k.length < 10)) {
            dataList = keys.map(k => ({ symbol: k, ...rawData[k] }));
        } else if (Array.isArray(rawData.table_data)) { dataList = rawData.table_data;
        } else if (Array.isArray(rawData.data)) dataList = rawData.data;
        else if (Array.isArray(rawData.positions)) dataList = rawData.positions;
        else if (Array.isArray(rawData.result)) dataList = rawData.result;
        else { dataList = [rawData]; }
    }

    const findSym = (sym) => {
        const search = (sym || '').toUpperCase();
        if(!search) return null;
        return dataList.find(p => {
            const s1 = (p.symbol || '').toUpperCase();
            const s2 = (p.ticker || '').toUpperCase();
            const s3 = (p.asset || '').toUpperCase();
            const s4 = (p.name || '').toUpperCase(); 
            return s1 === search || s2 === search || s3 === search || s4.includes(search);
        });
    };

    // --- Denom current exposure (auto) ---
    const foundDenom = findSym(denomSym);
    if(denomCurrentEl) {
        if(foundDenom) {
            const denomUsdVal = Number(foundDenom.net_exposure_usd_from_base || 0);
            if (!isNaN(denomUsdVal)) {
                const denomUnits = denomUsdVal / denomUsd;
                denomCurrentEl.value = denomUnits.toFixed(6);
                if(denomStatusEl) {
                    denomStatusEl.textContent = `Auto-Loaded: $${fmt(denomUsdVal, 0)} ${denomSym} exposure`;
                    denomStatusEl.style.color = 'var(--good)';
                }
            } else if(denomStatusEl) {
                denomStatusEl.textContent = `Found ${denomSym}, but invalid exposure.`;
                denomStatusEl.style.color = 'var(--warn)';
            }
        } else if(denomStatusEl) {
            denomStatusEl.textContent = `No position found for ${denomSym}.`;
            denomStatusEl.style.color = 'var(--muted)';
        }
    }

    // --- Numerator current exposure (auto) ---
    const foundAsset = findSym(assetSym);
    let assetUpdated = false;
    if (foundAsset) {
        const usdVal = Number(foundAsset.net_exposure_usd_from_base || 0);
        if (!isNaN(usdVal) && usdVal !== 0) {
            const denomExposure = usdVal / denomUsd;
            if(currentEEl) currentEEl.value = denomExposure.toFixed(6);
            if(statusEl) {
                statusEl.textContent = `Auto-Loaded: $${fmt(usdVal, 0)} exposure`;
                statusEl.style.color = 'var(--good)';
            }
            assetUpdated = true;
        } else if(statusEl) {
            statusEl.textContent = `Found ${assetSym}, but 0 exposure.`;
            statusEl.style.color = 'var(--warn)';
        }
    } else if(statusEl) {
        statusEl.textContent = `No position found for ${assetSym}.`;
        statusEl.style.color = 'var(--muted)';
    }

    updateTargetAtP0();
    if(assetUpdated) generate();

  } catch (err) {
    console.error(err);
    if(statusEl) {
        statusEl.textContent = `Fetch failed: ${err.message}`;
        statusEl.style.color = 'var(--bad)';
    }
    if(denomStatusEl) {
        denomStatusEl.textContent = `Fetch failed: ${err.message}`;
        denomStatusEl.style.color = 'var(--bad)';
    }
  } finally {
    if(indEl) indEl.style.display = 'none';
  }
}

/* -------------------------
   Bands builder
-------------------------- */
function buildBands(pmin, pmax, p0, stepPct){
  const step = stepPct/100.0;
  const down=[], up=[];
  // build down from p0 to pmin with multiplicative steps
  let p = p0;
  while(p>pmin*(1+1e-12)){
    const next = p/(1+step);
    const pa = Math.max(next, pmin);
    const pb = p;
    down.push({pa, pb});
    p = pa;
    if(down.length>2000) break;
  }
  // build up from p0 to pmax
  p = p0;
  while(p<pmax*(1-1e-12)){
    const next = p*(1+step);
    const pa = p;
    const pb = Math.min(next, pmax);
    up.push({pa, pb});
    p = pb;
    if(up.length>2000) break;
  }
  return {down, up};
}

/* -------------------------
   Target curve helper (used for display and P0 target)
-------------------------- */
function getUnitsHeldAt(p, pmin, pmax, portfolioSize, minPct, maxPct, distMode){
  const valMin = portfolioSize*(minPct/100);
  const valMax = portfolioSize*(maxPct/100);
  if(distMode === 'univ3'){
    // interpret as constant liquidity between pmin and pmax with no quote below p0 and no base above p0
    // We'll solve for L such that value at endpoints match and interpolate.
    // For simplicity, treat as linear in value when outside range.
    // Within range: holdings are x(p)*p where x(p)=L*(1/sqrt(p)-1/sqrt(pmax)).
    // We'll compute L using x(pmin)*pmin = valMin and x(pmax)*pmax = valMax (x(pmax)=0).
    // This becomes valMax ~ 0 at pmax in a pure univ3 full-range, so we fall back to linear.
    // Practically, use linear target between endpoints:
    const t = (p - pmin)/(pmax - pmin);
    const targetVal = valMin + (valMax - valMin)*clamp(t,0,1);
    return targetVal / p;
  }else{
    // uniform: linear value interpolation between endpoints.
    const t = (p - pmin)/(pmax - pmin);
    const targetVal = valMin + (valMax - valMin)*clamp(t,0,1);
    return targetVal / p;
  }
}

/* -------------------------
   Core schedule math (FIXED)
-------------------------- */
function calculateStrategy(params, manualBands) {
  const {
    pmin, pmax, p0, stepPct, portfolioSize, targetMinPct, targetMaxPct, currentE,
    denomSymbol, denomUsd, assetSymbol, scaleMode, distMode,
    denomCurrentE, denomTargetE
  } = params;

  if(!manualBands && !(pmin>0 && pmax>pmin && p0>0)) return null;
  let bands = manualBands;
  if (!bands) { bands = buildBands(pmin, pmax, p0, stepPct); }
  const Ndown = bands.down.length, Nup = bands.up.length;

  const effectivePmin = (pmin > 0) ? pmin : (bands.down.length > 0 ? bands.down[bands.down.length-1].pa : 0);
  const effectivePmax = (pmax > 0) ? pmax : (bands.up.length > 0 ? bands.up[bands.up.length-1].pb : 0);

  const scaleFactorAt = (px) => (scaleMode === 'scale' && p0 > 0) ? (px/p0) : 1;

  const targetMin = portfolioSize * targetMinPct / 100;
  const targetMax = portfolioSize * targetMaxPct / 100;

  const currentAtMin = currentE * scaleFactorAt(effectivePmin);
  const currentAtMax = currentE * scaleFactorAt(effectivePmax);

  const needMinDeltaDenom = (targetMin - currentAtMin);
  const needSellDeltaDenom = (currentAtMax - targetMax);

  // Units that must be bought (below) or sold (above) to hit endpoints.
  const needBuyUnitsTotal = (needMinDeltaDenom > 0 && effectivePmin > 0) ? (needMinDeltaDenom / effectivePmin) : 0;
  let needSellUnitsTotal = (needSellDeltaDenom > 0 && effectivePmax > 0) ? (needSellDeltaDenom / effectivePmax) : 0;

  // Denom budget: only allow spending denom surplus (current - target) on the below side.
  let denomBudget = Infinity;
  if (isFinite(denomCurrentE) && isFinite(denomTargetE)) {
    denomBudget = Math.max(0, denomCurrentE - denomTargetE);
  }

  // Above-side shorting: allow only if targetMax is negative (explicit short target).
  const buyShortAllowed = (targetMax < 0);

  // Holdings available to fund above-side sells (in asset units at P₀).
  const currentUnitsAtP0 = (p0 > 0) ? (currentE / p0) : 0;
  const holdingsAvailUnits = Math.max(currentUnitsAtP0, 0);

  if (!buyShortAllowed) {
    needSellUnitsTotal = Math.min(needSellUnitsTotal, holdingsAvailUnits);
  }

  // ---- BELOW sizing ----
  let perQuoteBelow = 0;     // equal-quote mode (quote per band)
  let L_Below = 0;           // UniV3 mode (liquidity)
  let belowQuoteRequired = 0;
  let belowQuoteUsed = 0;

  if (Ndown > 0 && needBuyUnitsTotal > 0) {
    if (distMode === 'univ3') {
      const termUnits = (1/Math.sqrt(effectivePmin)) - (1/Math.sqrt(p0));
      if (termUnits > 0) L_Below = needBuyUnitsTotal / termUnits;

      belowQuoteRequired = L_Below * (Math.sqrt(p0) - Math.sqrt(effectivePmin));
      let scale = 1;
      if (isFinite(denomBudget) && belowQuoteRequired > 0) scale = Math.min(1, denomBudget / belowQuoteRequired);
      L_Below *= scale;
      belowQuoteUsed = belowQuoteRequired * scale;
    } else {
      let sumUnitsPerQuote = 0;
      for (const b of bands.down) {
        sumUnitsPerQuote += 1 / (Math.sqrt(b.pa) * Math.sqrt(b.pb));
      }
      perQuoteBelow = sumUnitsPerQuote > 0 ? (needBuyUnitsTotal / sumUnitsPerQuote) : 0;
      belowQuoteRequired = perQuoteBelow * Ndown;

      let scale = 1;
      if (isFinite(denomBudget) && belowQuoteRequired > 0) scale = Math.min(1, denomBudget / belowQuoteRequired);
      perQuoteBelow *= scale;
      belowQuoteUsed = belowQuoteRequired * scale;
    }
  }

  // ---- ABOVE sizing ----
  let unitsPerBandAbove = 0; // equal-units mode
  let L_Above = 0;           // UniV3 mode
  if (Nup > 0 && needSellUnitsTotal > 0) {
    if (distMode === 'univ3') {
      const term = (1/Math.sqrt(p0)) - (1/Math.sqrt(effectivePmax));
      if (term > 0) L_Above = needSellUnitsTotal / term;
    } else {
      unitsPerBandAbove = needSellUnitsTotal / Nup;
    }
  }

  // ---- Build rows ----
  const rows = [];
  let belowTotal = 0;
  let aboveTotalQuote = 0;
  let aboveTotalUnits = 0;

  // Below (price moving down): accumulate bought units and revalue at the current boundary price.
  let cumBoughtUnits = 0;
  for (let i = 0; i < bands.down.length; i++) {
    const b = bands.down[i];
    let quote = 0, units = 0;
    if (needBuyUnitsTotal > 0) {
      if (distMode === 'univ3') {
        quote = L_Below * (Math.sqrt(b.pb) - Math.sqrt(b.pa));
        units = L_Below * (1/Math.sqrt(b.pa) - 1/Math.sqrt(b.pb));
      } else {
        quote = perQuoteBelow;
        units = quote / (Math.sqrt(b.pa) * Math.sqrt(b.pb));
      }
    }
    belowTotal += quote;
    cumBoughtUnits += units;

    const boundaryPx = b.pa;
    const currentUnitsAtBoundary = (currentE * scaleFactorAt(boundaryPx)) / boundaryPx;
    const netUnits = currentUnitsAtBoundary + cumBoughtUnits;
    const netAtBoundary = netUnits * boundaryPx;

    rows.push({
      bandIdx: b.origIdx || (i + 1),
      pa: b.pa, pb: b.pb, type: 'Below',
      deployUSD: quote,
      deployAltUsd: 0,
      sourceTag: '',
      altUnitsAbove: 0,
      netAtBoundary
    });
  }

  // Above (price moving up): accumulate sold units and revalue remaining units at the current boundary price.
  let cumSoldUnits = 0;
  let holdingsRemainingUnits = holdingsAvailUnits;
  for (let j = 0; j < bands.up.length; j++) {
    const b = bands.up[j];
    let units = 0;
    if (needSellUnitsTotal > 0) {
      if (distMode === 'univ3') {
        units = L_Above * (1/Math.sqrt(b.pa) - 1/Math.sqrt(b.pb));
      } else {
        units = unitsPerBandAbove;
      }
    }

    cumSoldUnits += units;
    aboveTotalUnits += units;

    const quoteOut = units * Math.sqrt(b.pa * b.pb);
    aboveTotalQuote += quoteOut;

    let sourceTag = '';
    if (units > 0) {
      if (holdingsRemainingUnits <= 1e-12) {
        sourceTag = '<span class="tag source">Buy+Short</span>';
      } else if (units <= holdingsRemainingUnits + 1e-12) {
        sourceTag = '<span class="tag hold">Holdings</span>';
        holdingsRemainingUnits -= units;
      } else {
        sourceTag = '<span class="tag hold">Holdings</span><span class="tag source">+Short</span>';
        holdingsRemainingUnits = 0;
      }
    }

    const boundaryPx = b.pb;
    const currentUnitsAtBoundary = (currentE * scaleFactorAt(boundaryPx)) / boundaryPx;
    const netUnits = currentUnitsAtBoundary - cumSoldUnits;
    const netAtBoundary = netUnits * boundaryPx;

    rows.push({
      bandIdx: b.origIdx || (Ndown + j + 1),
      pa: b.pa, pb: b.pb, type: 'Above',
      deployUSD: 0,
      deployAltUsd: quoteOut,
      sourceTag,
      altUnitsAbove: units,
      netAtBoundary
    });
  }

  // Residuals (0 means schedule hits the endpoint targets in denom terms).
  const boughtUnitsTotal = cumBoughtUnits;
  const soldUnitsTotal = cumSoldUnits;
  const residualMin = (effectivePmin > 0) ? (targetMin - (currentAtMin + boughtUnitsTotal * effectivePmin)) : 0;
  const residualMax = (effectivePmax > 0) ? (targetMax - (currentAtMax - soldUnitsTotal * effectivePmax)) : 0;

  return {
    rows,
    kpi: {
      Ndown, Nup,
      belowTotal,
      aboveTotalQuote,
      aboveTotalUnits,
      denomBudget,
      belowQuoteRequired,
      belowQuoteUsed,
      residualMin,
      residualMax
    },
    rawBands: bands
  };
}

function renderLPSection(title, strat){
  const dec = Number(document.getElementById('dec').value)||6;
  const denomUsd = strat.denomUsd || 0;
  const denomSymbol = (strat.denomSymbol||'').toUpperCase();

  const result = calculateStrategy(strat);
  if(!result) return `<div class="note">Invalid inputs for ${title}</div>`;
  const {rows, kpi} = result;

  const below = rows.filter(r=>r.type==='Below');
  const above = rows.filter(r=>r.type==='Above');

  const totalBelowDenom = below.reduce((a,b)=>a+(b.deployUSD||0),0);
  const totalAboveDenom = above.reduce((a,b)=>a+(b.deployAltUsd||0),0);
  const totalAboveUnits = above.reduce((a,b)=>a+(b.altUnitsAbove||0),0);

  const bandsPill = document.getElementById('bandsPill');
  if(bandsPill){
    bandsPill.textContent = `${(below.length+above.length)} bands`;
  }
  const modePill = document.getElementById('modePill');
  if(modePill){
    const m = strat.distMode === 'univ3' ? 'UniV3' : 'Uniform';
    modePill.textContent = m;
  }

  let html = `<div class="note"><b>${title}</b><div class="small muted">
    Denom: ${denomSymbol} &nbsp;|&nbsp; ALT: ${strat.assetSymbol} &nbsp;|&nbsp; Scale: ${strat.scaleMode}
  </div>
  <div class="small muted">
    Total Below: ${fmt(totalBelowDenom,dec)} ${denomSymbol} ($${fmt(totalBelowDenom*denomUsd,2)})
    &nbsp;|&nbsp;
    Total Above: ${fmt(totalAboveDenom,dec)} ${denomSymbol} ($${fmt(totalAboveDenom*denomUsd,2)})
    &nbsp;|&nbsp;
    Units sold above: ${fmt(totalAboveUnits,dec)} ${strat.assetSymbol}
  </div>
  </div>`;

  html += `<table>
    <thead>
      <tr>
        <th>Band</th>
        <th>Type</th>
        <th>Pa</th>
        <th>Pb</th>
        <th>Deploy Below (${denomSymbol})</th>
        <th>Sell Above (Units)</th>
        <th>Receive Above (${denomSymbol})</th>
        <th>Source</th>
      </tr>
    </thead>
    <tbody>
  `;
  rows.sort((a,b)=>a.pa-b.pa);
  rows.forEach((r, i)=>{
    html += `<tr>
      <td class="mono">${r.bandIdx ?? (i+1)}</td>
      <td>${r.type}</td>
      <td class="mono">${fmt(r.pa, dec)}</td>
      <td class="mono">${fmt(r.pb, dec)}</td>
      <td class="mono">${r.type==='Below'?fmt(r.deployUSD||0, dec):''}</td>
      <td class="mono">${r.type==='Above'?fmt(r.altUnitsAbove||0, dec):''}</td>
      <td class="mono">${r.type==='Above'?fmt(r.deployAltUsd||0, dec):''}</td>
      <td>${r.sourceTag||''}</td>
    </tr>`;
  });
  html += `</tbody></table>`;
  return html;
}

/* -------------------------
   Main generate
-------------------------- */
function generate() {
  const assetSymbol = document.getElementById('assetSelect').value;
  const denomSymbol = document.getElementById('denomSelect').value;
  const denomUsd = Number(document.getElementById('denomUsd').value) || 0;

  const altUsd = Number(document.getElementById('altUsd').value) || 0;
  const p0 = Number(document.getElementById('p0').value) || 0;
  const pmin = Number(document.getElementById('pmin').value) || 0;
  const pmax = Number(document.getElementById('pmax').value) || 0;

  const portfolioSize = Number(document.getElementById('portfolioSize').value) || 0;
  const currentE = Number(document.getElementById('currentE').value) || 0;
  const denomCurrentE = Number(document.getElementById('denomCurrentE').value);
  const denomTargetE = Number(document.getElementById('denomTargetE').value);

  const targetMinPct = Number(document.getElementById('targetMinPct').value) || 0;
  const targetMaxPct = Number(document.getElementById('targetMaxPct').value) || 0;
  const stepPct = Number(document.getElementById('intervalPct').value) || 1;
  const maxBands = Number(document.getElementById('maxBands').value) || 50;
  const dec = Number(document.getElementById('dec').value) || 6;
  const capitalRatio = Number(document.getElementById('capitalRatio').value) || 1;
  const scaleMode = document.getElementById('scaleMode').value;
  const distMode = document.getElementById('distMode').value;
  const scheduleMode = document.getElementById('scheduleMode').value;

  if(!(p0>0 && pmin>0 && pmax>0 && pmin<p0 && p0<pmax)){
    document.getElementById('outArea').innerHTML = `<div class="note">Invalid price inputs. Require Pmin &lt; P₀ &lt; Pmax and all &gt; 0.</div>`;
    return;
  }

  // enforce max bands by increasing interval if necessary
  const tmpBands = buildBands(pmin,pmax,p0,stepPct);
  if(tmpBands.down.length>maxBands || tmpBands.up.length>maxBands){
    // we don't auto-adjust, but warn:
    console.warn("Band count exceeds max; consider increasing interval % or max bands.");
  }

  const baseParams = { pmin, pmax, p0, stepPct, portfolioSize: portfolioSize * capitalRatio, currentE: currentE * capitalRatio, denomCurrentE: denomCurrentE * capitalRatio, denomTargetE: denomTargetE * capitalRatio, denomSymbol, denomUsd, assetSymbol, scaleMode, distMode };

  const out = document.getElementById('outArea');
  let html = '';

  if(scheduleMode === 'single'){
    html += renderLPSection('LP Schedule', baseParams);
  } else {
    // Dual: create two strategies. LP1 uses asset/denom, LP2 uses denom/USD side (proxy).
    const lp2SplitPct = Number(document.getElementById('lp2SplitPct').value)||50;
    const lp2RangeMult = Number(document.getElementById('lp2RangeMult').value)||1.5;
    const split = clamp(lp2SplitPct/100, 0, 1);

    // LP1 uses portion (1-split) of portfolio and exposure
    const lp1Params = { ...baseParams, portfolioSize: baseParams.portfolioSize*(1-split), currentE: baseParams.currentE*(1-split) };

    // LP2 (USD) uses split portion, denom=USD, asset=denomSymbol as numerator (denom/USD)
    const lp2P0 = denomUsd; // denom/USD
    const lp2Pmin = denomUsd / lp2RangeMult;
    const lp2Pmax = denomUsd * lp2RangeMult;

    // For lp2 current exposure, approximate as denomCurrentE*(split) in USD denom.
    const lp2CurrentE = (Number(document.getElementById('denomCurrentE').value)||0) * denomUsd * split * capitalRatio;
    const lp2PortfolioSize = (baseParams.portfolioSize * denomUsd) * split; // convert denom to USD

    const lp2Params = {
      pmin: lp2Pmin,
      pmax: lp2Pmax,
      p0: lp2P0,
      stepPct,
      portfolioSize: lp2PortfolioSize,
      currentE: lp2CurrentE,
      denomSymbol: 'USD',
      denomUsd: 1, denomCurrentE: NaN, denomTargetE: NaN,
      assetSymbol: denomSymbol,
      scaleMode,
      distMode
    };

    html += renderLPSection('LP 1 (ALT/' + denomSymbol + ')', lp1Params);
    html += '<div class="sep"></div>';
    html += renderLPSection('LP 2 (USD proxy for ' + denomSymbol + ')', lp2Params);
  }

  out.innerHTML = html;
}

/* -------------------------
   Asset config loader (optional)
-------------------------- */
async function loadAssetList(){
  try{
    const data = await fetchJson('/api/config');
    const assets = data.assets || [];
    const assetSel = document.getElementById('assetSelect');
    assetSel.innerHTML = '';
    assets.forEach(a=>{
      const opt = document.createElement('option');
      opt.value = a.symbol;
      opt.textContent = `${a.symbol} — ${a.name||''}`;
      assetSel.appendChild(opt);
    });
    if(assets.length){
      assetSel.value = assets[0].symbol;
      await loadAssetConfig(assetSel.value);
    }
  }catch(err){
    console.warn("Config load failed; using fallback list.", err);
    const fallback = ['LTC','ETH','SOL','AVAX','BNB','XRP','DOGE','LINK'];
    const assetSel = document.getElementById('assetSelect');
    assetSel.innerHTML = '';
    fallback.forEach(s=>{
      const opt=document.createElement('option');
      opt.value=s; opt.textContent=s;
      assetSel.appendChild(opt);
    });
    assetSel.value = fallback[0];
  }
}

async function loadAssetConfig(sym){
  try{
    const cfg = await fetchJson('/api/config');
    const a = (cfg.assets||[]).find(x=>x.symbol===sym);
    if(!a) return;

    // set defaults from config if present
    if(a.defaultPmin) document.getElementById('pmin').value = a.defaultPmin;
    if(a.defaultPmax) document.getElementById('pmax').value = a.defaultPmax;
    if(a.defaultPortfolioSize) document.getElementById('portfolioSize').value = a.defaultPortfolioSize;
    if(a.defaultTargetMinPct!=null) document.getElementById('targetMinPct').value = a.defaultTargetMinPct;
    if(a.defaultTargetMaxPct!=null) document.getElementById('targetMaxPct').value = a.defaultTargetMaxPct;
    if(a.defaultIntervalPct!=null) document.getElementById('intervalPct').value = a.defaultIntervalPct;
    if(a.defaultScaleMode) document.getElementById('scaleMode').value = a.defaultScaleMode;

    // prices
    const denom = document.getElementById('denomSelect').value;
    await autoFetchPrices(sym, denom);

    // if config includes P0 override
    if(a.defaultP0) document.getElementById('p0').value = a.defaultP0;

    updateAutoTargets();
    triggerAutoFetch();
    fetchLiveExposure();
    generate();
  }catch(err){
    console.warn("Asset config load failed", err);
  }
}

/* -------------------------
   Init
-------------------------- */
(function init(){
  const assetSel = document.getElementById('assetSelect');
  const denomSel = document.getElementById('denomSelect');
  const btnFetch = document.getElementById('btnFetch');
  const btnAuto = document.getElementById('btnAutoPrices');
  const btnGen = document.getElementById('btnGen');
  const btnClear = document.getElementById('btnClear');

  const altUsdEl = document.getElementById('altUsd');
  const denomUsdEl = document.getElementById('denomUsd');
  const p0El = document.getElementById('p0');

  btnFetch.addEventListener('click', fetchLiveExposure);
  btnAuto.addEventListener('click', ()=>autoFetchPrices(assetSel.value, denomSel.value));
  btnGen.addEventListener('click', generate);
  btnClear.addEventListener('click', ()=>{ document.getElementById('outArea').innerHTML = `<div class="note">Cleared.</div>`; });

  altUsdEl.addEventListener('input', updateP0FromUsd);
  denomUsdEl.addEventListener('input', updateP0FromUsd);
  p0El.addEventListener('input', updateUsdFromP0);

  assetSel.addEventListener('change', () => {
      loadAssetConfig(assetSel.value);
      updateDenomLabels(denomSel.value);
  });
  denomSel.addEventListener('change', () => {
      updateDenomLabels(denomSel.value);
      updateTargetAtP0();
      autoFetchPrices(assetSel ? assetSel.value : '', denomSel.value);
  });

  // Auto target updates when inputs change
  ['portfolioSize', 'targetMinPct', 'targetMaxPct'].forEach(id => {
      const el = document.getElementById(id);
      if(el) el.addEventListener('input', updateAutoTargets);
  });
  const denomTargetEl = document.getElementById('denomTargetE');
  if(denomTargetEl) denomTargetEl.addEventListener('input', updateDenomDelta);
  const distModeEl = document.getElementById('distMode');
  if(distModeEl) distModeEl.addEventListener('change', updateAutoTargets);
  ['pmin', 'pmax'].forEach(id => {
      const el = document.getElementById(id);
      if(el) el.addEventListener('input', updateAutoTargets);
  });

  // initial setup
  updateDenomLabels(denomSel.value);
  loadAssetList();
  autoFetchPrices('', denomSel.value);
})();
</script>
</body>
</html>
